<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[做题计划]]></title>
    <url>%2Fpassages%2F%E5%81%9A%E9%A2%98%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[队列：P2253 好一个一中腰鼓！ （线段树 绿题）P3939 数颜色 （线段树 蓝题）P3919 【模板】可持久化数组（可持久化线段树/平衡树） （模板 蓝题）P4188 [USACO18JAN]Lifeguards S （线段树 蓝题）P2982 [USACO10FEB]慢下来Slowing down （线段树 蓝题）P1904 天际线 （线段树 蓝题）P1637 三元上升子序列 （线段树 蓝题）P4879 ycz的妹子 （线段树 蓝题）P4969 神秘的703 （线段树 蓝题）P3801 红色的幻想乡 （线段树 蓝题）P3932 浮游大陆的68号岛 （线段树/前缀和 蓝题）P4422 [COCI2017-2018#1] Deda （线段树 蓝题）P2471 [SCOI2007]降雨量 （线段树 紫题）P1712 [NOI2016]区间 （线段树 紫题）P3899 [湖南集训]谈笑风生 （主席树 紫题）P3391 【模板】文艺平衡树（Splay） （模板 紫题）P1502 窗口的星星 （线段树 紫题）CF558E A Simple Task （线段树 紫题）[CF787D 遗产]P1486 [NOI2004]郁闷的出纳员 （平衡树 紫题）P1118 [USACO06FEB]数字三角形 （搜索 黄题）P1825 [USACO11OPEN]玉米田迷宫Corn Maze （搜索 绿题）24分P1083 借教室 （二分 蓝题）P1201 [USACO1.1]贪婪的送礼者Greedy Gift Givers （USACO专题 橙题）P1080 国王游戏 （贪心 蓝题）P1197 [JSOI2008]星球大战 或 P1196 [NOI2002]银河英雄传说 （并查集 蓝题）P1113 杂务（图论 黄题）P1983 车站分级 （图论 黄题）P1338 末日的传说 （数论 黄题）P1108 低价购买 （DP 蓝题）P1582 倒水 （数论 绿题）P1220 关路灯 （DP 绿题）P1373 小a和uim之大逃离 （DP 蓝题）P2279 [HNOI2003]消防局的设立 （搜索 蓝题）P1070 道路游戏 （DP 蓝题）CF940E Cashback（DP 蓝题）P2123 皇后游戏 （贪心 紫题）CF721E Road to Home （DP 灰题）CF939F Cutlet （DP 黑题）]]></content>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 141B Hopscotch]]></title>
    <url>%2Fpassages%2F2019-04-29-CF141B%2F</url>
    <content type="text"><![CDATA[传送门：CF141B Hopscotch题目描述： 有$n$个形状和大小都一致的正方体积木，积木堆积的样式是第一层只有一个正方体，然后上面就开始循环了，循环体为：第一层是一个正方体，第二层是两个正方体。如下图所示：现在给你三个数，表示正方体的边长，然后让你输出坐标$(x,y)$对应的数。如果在积木的边界上或者是不在正方体上输出$-1$。算法分析： 判断是否在边界上（$a|y$），是否在第一、二象限($y&gt;0$) 接着，判断 $y$ 是否比 $a$ 小，$x$是否在第一个正方形内 将$y$减去$a$（删去第一层），$dir=\frac{y}{2a}+1$ 表示其所在的层数 然后就可以得到当前可能位置下的个数 $bottom=(dir-1)*3+2$ ，并把可能位置以下的层数减去 最后再做一遍第一步的判断时间复杂度：$O(1)$ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int a,y; double x;void work();int main()&#123; cin&gt;&gt;a&gt;&gt;x&gt;&gt;y; if(y%a==0 || y&lt;=0) printf("-1"); else work(); return 0;&#125;void work()&#123; if(y&gt;0 &amp;&amp; y&lt;a &amp;&amp; x&gt;-a*1.0/2 &amp;&amp; x&lt;a*1.0/2) &#123;printf("1"); return;&#125; y-=a; int dir=y/(2*a)+1; int bottom=(dir-1)*3+2; y-=(dir-1)*2*a; if(y&gt;0 &amp;&amp; y&lt;a) if(x&gt;-a*1.0/2 &amp;&amp; x&lt;a*1.0/2) &#123; printf("%d",bottom); return; &#125; if(y&gt;a &amp;&amp; y&lt;a*2) &#123; if(x==0) &#123;printf("-1"); return;&#125; if(x&gt;-a &amp;&amp; x&lt;0) &#123; printf("%d",bottom+1); return; &#125; else if(x&gt;0 &amp;&amp; x&lt;a) &#123; printf("%d",bottom+2); return; &#125; &#125; printf("-1");&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>平面几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1018 乘积最大]]></title>
    <url>%2Fpassages%2F2019-04-29-P1018%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1018 乘积最大 算法分析：首先，算法主体为区间DP，设 $f[i][j]$ 为在中分i个乘号的最大结果则 $f[i][j]=max\{f[i][j],f[i-1][t]\times a[t+1][j]\}$其中 $i\in[1,k]$ , $j\in[i+1,n]$ , $t\in[i,j)$ , $a$ 中存储所有拆分数 考虑到本题的数据量，使用高精度乘法计算高精度乘法实现：分为5个函数： remix ：将数组中的数右对齐 give ：将数组中的内容拷贝到另一个数组中 write ：去前导0并输出 comp ：比较函数 multi ：进行竖式运算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef unsigned long long ull;const int maxN=100;struct Node&#123; int num[maxN+1];&#125;;int n,k,a[maxN+1],b[maxN+1],c[maxN+1];char s[maxN+1];Node dp[maxN+1][maxN+1];ull a1[maxN+1][maxN+1];void remix(int[],ull),reset(),DP();void multi(int[],int[]);void give(int[],int[]),write();int comp(int[],int[]);int main()&#123; reset(); DP(); write(); return 0;&#125;void remix(int a[],ull num)&#123; int len=0,lent=0; ull temp=num; while(num) &#123;lent++; num/=10;&#125; len=lent; while(temp) &#123;a[--lent]=temp%10; temp/=10;&#125; for(int i=maxN;i&gt;=0;i--,len--) if(len&gt;0) a[i]=a[len-1]; else a[i]=0;&#125;void reset()&#123; scanf("%d%d%s",&amp;n,&amp;k,s); memset(a1,0,sizeof(a1)); for(int i=0;i&lt;n;i++) for(int j=i;j&lt;n;j++) a1[i+1][j+1]=a1[i+1][j]*10+s[j]-'0'; for(int i=0;i&lt;=n;i++) remix(dp[0][i].num,a1[1][i]);&#125;void DP()&#123; for(int i=1;i&lt;=k;i++) for(int j=i+1;j&lt;=n;j++) &#123; memset(dp[i][j].num,0,sizeof(dp[i][j].num)); for(int t=i;t&lt;j;t++) &#123; memset(c,0,sizeof(c)); int now[maxN+1]=&#123;0&#125;; remix(now,a1[t+1][j]); multi(dp[i-1][t].num,now); if(comp(dp[i][j].num,c)==-1) give(dp[i][j].num,c); &#125; &#125;&#125;void write()&#123; int i=0; while(i&lt;maxN &amp;&amp; dp[k][n].num[i]==0) i++; while(i&lt;=maxN) printf("%d",dp[k][n].num[i++]);&#125;void multi(int a[],int b[])&#123; int jw,t; for(int i=maxN;i&gt;maxN/2;i--) &#123; jw=0; t=i; for(int j=maxN;j&gt;maxN/2;j--) &#123; c[t]+=a[i]*b[j]+jw; jw=c[t]/10; c[t--]%=10; &#125; c[t--]=jw; &#125;&#125;int comp(int a[],int b[])&#123; int len1=0,len2=0; while(a[len1]==0) len1++; while(b[len2]==0) len2++; if(len1&lt;len2) return 1; if(len1&gt;len2) return -1; for(;len1&lt;=maxN;len1++) &#123; if(a[len1]&lt;b[len1]) return -1; if(a[len1]&gt;b[len1]) return 1; &#125; return 0;&#125;void give(int change[],int own[])&#123; for(int i=0;i&lt;=maxN;i++) change[i]=own[i];&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>高精</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P3146 248]]></title>
    <url>%2Fpassages%2F2019-04-29-P3146%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P3146 248算法分析：设 $f[i][j]$ 为合并 $i-j$ 位的最大数字，那么满足 $f[i][k-1]==f[k][j]$ （即判断前一段的值能否和后一段的再次合并）时，$f[i][j]=max(f[i][j],f[i][k-1]+1)$（合并后的值$+1$），最后取最佳值（枚举 $f[i][j]$ ） 时间复杂度：$O(n^3)$ 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxN=248;int n,dp[maxN+1][maxN+1],ans=0;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;dp[i][i]); for(int i=n-1;i&gt;=1;i--) for(int j=i+1;j&lt;=n;j++) for(int k=i-1;k&lt;=j;k++) if(dp[i][k-1]==dp[k][j]) dp[i][j]=max(dp[i][j],dp[i][k-1]+1); for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j++) ans=max(ans,dp[i][j]); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1006 传纸条]]></title>
    <url>%2Fpassages%2F2019-04-29-P1006%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1006 传纸条算法分析：首先想到两张纸条同时传，则是四维DP，转移方程如下： dp[i][j][l][r]=max\{dp[i-1][j][l-1][r],dp[i-1][j][l][r-1],dp[i][j-1][l-1][r],dp[i][j-1][l][r-1]\}+a[i][j]+a[l][r]表示分两条路径传播变形：洛谷 P1004 方格取数 时间复杂度：$O(n^4)$ 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxN=50;int m,n,a[maxN+1][maxN+1];int dp[maxN+1][maxN+1][maxN+1][maxN+1];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int l=1;l&lt;=n;l++) for(int r=j+1;r&lt;=m;r++) dp[i][j][l][r]=max(dp[i-1][j][l-1][r],max(dp[i-1][j][l][r-1],max(dp[i][j-1][l-1][r],dp[i][j-1][l][r-1])))+a[i][j]+a[l][r]; printf("%d",dp[n][m-1][n-1][m]); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>多维DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1044 栈]]></title>
    <url>%2Fpassages%2F2019-04-29-P1044%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1044 栈算法分析：卡特兰数（传送门：卡特兰数） C_n=C_0\times C_{n-1}+C_1\times C_{n-2}+…+C_{n-1}\times C_0 时间复杂度 $O(n^2)$ 123456789101112131415#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxN=18;int n,h[maxN+1];int main()&#123; scanf("%d",&amp;n); h[0]=h[1]=1; for(int i=2;i&lt;=n;i++) for(int j=0;j&lt;i;j++) h[i]+=h[j]*h[n-1-i]; printf("%d",h[n]); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1725 琪露诺]]></title>
    <url>%2Fpassages%2F2019-04-29-P1725%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1725 琪露诺算法分析：设 $dp[i]$ 为走到i位置的最大价值，则 $dp[i]=max(dp[i],dp[i-j]+a[i])$ , 其中$i\in[l,n]$，$j\in[l,r]$最后答案即为 $max\{dp[i]\}$，其中$i\in[n-r+1,n]$此方法时间复杂度为 $O(n^2)$ ，对于 $maxN=2\times10^5$ 是超出的再观察该方程，其中 $dp[i],a[i]$ 为定值，只要求在$i\in[l,n]$，$j\in[l,r]$ 区间中 $dp[i-j]$ 的最大值，使用单调队列算法来优化 时间复杂度：$O(n)$ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxN=200000;int a[maxN+1],dp[maxN+10],q[maxN+1];int n,l,r,ans=0,q_head,q_tail,num[maxN+1];inline int read();int main()&#123; n=read(); l=read(); r=read(); for(int i=0;i&lt;=n;i++) a[i]=read(); q_head=1; q_tail=0; for(int i=l;i&lt;=n;i++) &#123; while(dp[i-l]&gt;=q[q_tail] &amp;&amp; q_head&lt;=q_tail) q_tail--; num[++q_tail]=i-l; q[q_tail]=dp[i-l]; while(i-num[q_head]&gt;r-l) q_head++; dp[i]=q[q_head]+a[i]; &#125; for(int i=n-r+1;i&lt;=n;i++) ans=max(ans,dp[i]); printf("%d",ans); return 0;&#125;inline int read()&#123; char ch=getchar(); int num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') &#123;f=-1; ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123; num=num*10+ch-'0'; ch=getchar(); &#125; return num*f;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1043 数字游戏]]></title>
    <url>%2Fpassages%2F2019-04-08-P1043%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1043 数字游戏题目描述： 有这样一个游戏：在你面前有一圈整数（一共$n$个），你要按顺序将其分为$m$个部分，各部分内的数字相加，相加所得的$m$个结果对$10$取模后再相乘，最终得到一个数$k$。游戏的要求是使你所得的$k$最大或者最小。例如，对于下面这圈数字（$n=4,m=2$）：要求最小值时，$((2−1)\ mod\ 10)\times((4+3)\ mod\ 10)=1×7=7$，要求最大值时，$((2+4+3)\ mod\ 10)×(−1\ mod\ 10)=9×9=81$。特别值得注意的是，无论是负数还是正数，对$10$取模的结果均为非负值。 算法分析：首先，这张图是一个环的形式，题目大意是要对任意一段求和，故使用前缀和算法，并将数据重复储存来把环破开成链。其次，这道题用区间DP，以最大值为例：设 $dp[i][j][t]$ 为从 $i$ 到 $j$ 中分为 $t$ 部分所得的最大价值，则$dp[i][j][t] = max(dp[i][j][t],dp2[i][k-1][t-1]*(a[j]-a[k-1])\%10)$其中 $t$ 从 $2$ 到 $m$ ， $i$ 从 $1$ 到 $2n$（环破成链），$j$ 从 $i+t-1$（从 $i$ 开始的 $t$ 个数）到 $2n$。每次将 $dp_1$（求最小值）设为 $inf$，枚举区间 $k$，最后枚举开始位，求取 $n$ 位并分割 $m$ 次中的最大（小）值。 时间复杂度 $O(mn^3)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxN=100,maxM=9,inf=2147483647;int dp1[maxN+1][maxN+1][maxM+1];int dp2[maxN+1][maxN+1][maxM+1];int n,m,a[maxN+1];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); a[n+i]=a[i]; &#125; n*=2; for(int i=2;i&lt;=n;i++) a[i]+=a[i-1]; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j++) dp1[i][j][1]=dp2[i][j][1]=((a[j]-a[i-1])%10+10)%10; for(int t=2;t&lt;=m;t++) for(int i=1;i&lt;=n;i++) for(int j=i+t-1;j&lt;=n;j++) &#123; dp1[i][j][t]=inf; for(int k=i+t-1;k&lt;=j;k++) &#123; int temp=((a[j]-a[k-1])%10+10)%10; dp1[i][j][t]=min(dp1[i][j][t],dp1[i][k-1][t-1]*temp); dp2[i][j][t]=max(dp2[i][j][t],dp2[i][k-1][t-1]*temp); &#125; &#125; n/=2; int maxT=0,minT=inf; for(int i=1;i&lt;=n;i++) &#123; maxT=max(dp2[i][i+n-1][m],maxT); minT=min(dp1[i][i+n-1][m],minT); &#125; printf("%d\n%d",minT,maxT); getchar(); getchar(); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P2347 砝码称重]]></title>
    <url>%2Fpassages%2F2019-04-08-P2347%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P2347 砝码称重题目描述： 设有$1g$、$2g$、$3g$、$5g$、$10g$、$20g$的砝码各若干枚（其总重$\leq1000$），求用这些砝码能称出的不同重量的个数。算法分析：两重循环枚举所用砝码时间复杂度 $O(maxT\times maxM \times maxN)$ 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxM=1000;const int w[7]=&#123;0,1,2,3,5,10,20&#125;;int box[maxM+1],num[7],sum=0;int main()&#123; box[0]=1; for(int i=1;i&lt;=6;i++) scanf("%d",&amp;num[i]); for(int i=1;i&lt;=6;i++) for(int j=1;j&lt;=num[i];j++) for(int k=maxM;k&gt;=0;k--) if(k+w[i]&lt;=maxM &amp;&amp; box[k]) box[k+w[i]]=1; for(int i=1;i&lt;=maxM;i++) if(box[i]) sum++; printf("Total=%d",sum); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P4145 上帝造题的七分钟2 / 花神游历各国]]></title>
    <url>%2Fpassages%2F2019-04-07-P4145%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P4145 上帝造题的七分钟2 / 花神游历各国题目描述： 将区间内的每个数开平方，并区间求和 算法分析：$\sqrt{x}$ 向下取整，那么$\forall x \in R$，在经过有限次开平方运算后，其结果一定为$1$。故只需将大于$1$的区间的数开平方即可，就能大大降低时间复杂度，然后在更新时只要递归修改即可（$10^{12}$至多需要6次修改），查询时区间查询。在这里用了两个数组：$sum$ 和 $maxi$，$sum$存储和，$maxi$储存区间最大值。若区间最大值 $&gt;1$，则需修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#define ls k&lt;&lt;1#define rs k&lt;&lt;1 | 1#define mid ((l+r)&gt;&gt;1)#define G ch=getchar()#define in(x) x=read()#define S(x) x=(int)sqrt(x)using namespace std;const int maxN=100000;typedef long long rd;typedef long long ll;inline rd read();int n,m,l,r,op;ll sum[4*maxN+1],maxi[4*maxN+1];void update(int,int,int,int,int);ll query(int,int,int,int,int);void build(int,int,int),pushup(int);int main()&#123; in(n); build(1,1,n); in(m); for(register int i=1;i&lt;=m;i++) &#123; in(op); in(l); in(r); if(l&gt;r) swap(l,r); if(op==0) update(1,1,n,l,r); else printf("%lld\n",query(1,1,n,l,r)); &#125; return 0;&#125;void pushup(int k)&#123; sum[k]=sum[ls]+sum[rs]; maxi[k]=max(maxi[ls],maxi[rs]);&#125;void update(int k,int l,int r,int ql,int qr)&#123; if(l==r) &#123;S(sum[k]); S(maxi[k]); return;&#125; if(ql&lt;=mid &amp;&amp; maxi[ls]&gt;1) update(ls,l,mid,ql,qr); if(qr&gt;mid &amp;&amp; maxi[rs]&gt;1) update(rs,mid+1,r,ql,qr); pushup(k);&#125;ll query(int k,int l,int r,int ql,int qr)&#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sum[k]; ll ans=0; if(ql&lt;=mid) ans+=query(ls,l,mid,ql,qr); if(qr&gt;mid) ans+=query(rs,mid+1,r,ql,qr); return ans;&#125;void build(int k,int l,int r)&#123; if(l==r) &#123;in(sum[k]); maxi[k]=sum[k]; return;&#125; build(ls,l,mid); build(rs,mid+1,r); pushup(k);&#125;inline rd read()&#123; char ch=getchar(); rd num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') G; if(ch=='-') &#123;f=-1; G;&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123;num=num*10+ch-'0'; G;&#125; return num*f;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1095 守望者的逃离]]></title>
    <url>%2Fpassages%2F2019-04-07-P1095%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1095 守望者的逃离题目描述： 恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。守望者的跑步速度为$17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在$1s$内移动$60m$，不过每次使用闪烁法术都会消耗魔法值$10$点。守望者的魔法值恢复的速度为$4$点$/s$，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值$M$，他所在的初始位置与岛的出口之间的距离$S$，岛沉没的时间$T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意：守望者跑步、闪烁或休息活动均以秒$(s)$为单位，且每次活动的持续时间为整数秒。距离的单位为米$(m)$。 算法分析：分两种情况：1、运用贪心，尽可能用闪烁法术2、枚举秒数，判断此时用跑步速度是否能获得更大收益 时间复杂度：$O(t)$ 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxT=300000;int t,m,s,dp[maxT+1],ans=0;int main()&#123; scanf("%d%d%d",&amp;m,&amp;s,&amp;t); for(int i=1;i&lt;=t;i++) &#123; if(m&gt;=10) &#123;dp[i]=dp[i-1]+60; m-=10;&#125; else &#123;dp[i]=dp[i-1]; m+=4;&#125; &#125; for(int i=1;i&lt;=t;i++) &#123; dp[i]=max(dp[i],dp[i-1]+17); if(dp[i]&gt;=s) &#123;ans=i; break;&#125; &#125; if(ans) printf("%d",ans); else printf("%d",dp[s]); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P4667 Switch the Lamp On]]></title>
    <url>%2Fpassages%2F2019-04-07-P4667%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P4667 Switch the Lamp On重题（弱化版）：洛谷 P2243 电路维修题目描述： 每条电线可旋转 $90^\circ$指向另一方向，则求从左上角到右下角最少要旋转的次数 算法分析： 前言：为了测试算法速度，本题没有谜の卡常 $BFS\ ?$ 貌似对我这样的蒟蒻不太友好。该题本质上是沿对角线有一条路径，只不过其中顺着原电线方向的权值为$0$，反之为$1$，这样跑一遍$Dijkstra$即可。（自从过于不友好的 P4779 单源最短路径（标准版）后就转用$Dijkstra$）果断套堆优化模板—— 突然发现：NM=250000 ???那前面的$WA$呢？经过深思熟虑，突然发现：对角线的连线是$NM$，这就意味着图是以点的形式呈现时，应是$(N+1)\times(M+1)$，果断套堆优化模板（第一次用$class$还有点小激动）—— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#define in(x) x=read();using namespace std;const int maxN=1000001,maxM=1000001,maxQ=500;class algorithm&#123; public: int dis[maxN+1]; void addedge(int x,int y,int value) &#123; tot++; edge[tot].from=x; edge[tot].to=y; edge[tot].value=value; edge[tot].next=head[x]; head[x]=tot; &#125; void addtwo(int x,int y,int value) &#123; addedge(x,y,value); addedge(y,x,value); &#125; void clear() &#123; memset(dis,0x3f,sizeof(dis)); memset(vis,false,sizeof(vis)); memset(head,0,sizeof(head)); tot=0; &#125; void dijkstra(int s) &#123; dis[s]=0; q.push(make_pair(0,s)); while(q.size()) &#123; int x=q.top().second; q.pop(); if(vis[x]) continue; vis[x]=true; for(int i=head[x];i;i=edge[i].next) &#123; if(dis[edge[i].to]&gt;dis[x]+edge[i].value) &#123; dis[edge[i].to]=dis[x]+edge[i].value; q.push(make_pair(-dis[edge[i].to],edge[i].to)); &#125; &#125; &#125; &#125; private: struct Node &#123; int value,from,to,next; &#125;edge[maxM+1]; int head[maxN+1],tot; bool vis[maxN+1]; priority_queue&lt;pair&lt;int,int&gt; &gt; q;&#125;;int n,m,x,y,z;char map[maxQ+1][maxQ+1];algorithm task;void subtask();inline int read();int main()&#123; subtask(); return 0;&#125;void subtask()&#123; task.clear(); in(n); in(m); n++; m++; for(int i=1;i&lt;n;i++) scanf("%s",map[i]+1); for(int i=1;i&lt;n;i++) for(int j=1;j&lt;m;j++) if(map[i][j]==92) &#123; task.addtwo(i*m-m+j,i*m+j+1,0); task.addtwo(i*m-m+j+1,i*m+j,1); &#125; else &#123; task.addtwo(i*m-m+j,i*m+j+1,1); task.addtwo(i*m-m+j+1,i*m+j,0); &#125; task.dijkstra(1); if(task.dis[n*m]==0x3f3f3f3f) printf("NO SOLUTION\n"); else printf("%d\n",task.dis[n*m]);&#125;inline int read()&#123; char ch=getchar(); int num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') &#123;f=-1; ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123; num=num*10+ch-'0'; ch=getchar(); &#125; return num*f;&#125; ——然而并不是$AC$。那几个TLE是什么意思！经过认真观察，突然发现： 时空限制 150ms / 128MB 显然，用$priority\ queue$是不够快的（然而吸氧过了），那当然是要用线段树优化了（堆：？？？），然后就去了解了一下线段树优化 $Dijkstra$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#define ls k&lt;&lt;1#define rs k&lt;&lt;1|1#define mid ((l+r)&gt;&gt;1)#define in(x) x=read();using namespace std;const int maxN=500001,maxM=1000001;const int inf=0x3f3f3f3f,maxQ=500;class algorithm&#123; public: int dis[maxN+1]; void addedge(int x,int y,int value) &#123; tot++; edge[tot].from=x; edge[tot].to=y; edge[tot].value=value; edge[tot].next=head[x]; head[x]=tot; &#125; void addtwo(int x,int y,int value) &#123; addedge(x,y,value); addedge(y,x,value); &#125; void clear() &#123; memset(dis,0x3f,sizeof(dis)); memset(vis,false,sizeof(vis)); memset(head,0,sizeof(head)); memset(sum,0x3f,sizeof(sum)); tot=0; &#125; void update(int k,int l,int r,int u,int w) &#123; if(l==r) &#123;sum[k]=w; return;&#125; if(u&lt;=mid) update(ls,l,mid,u,w); else update(rs,mid+1,r,u,w); pushup(k); &#125; int query(int k,int l,int r) &#123; if(l==r) return l; if(sum[ls]&lt;sum[rs]) return query(ls,l,mid); else return query(rs,mid+1,r); &#125; void dijkstra(int s,int n) &#123; dis[s]=0; update(1,1,n,s,0); while(sum[1]^inf) &#123; int x=query(1,1,n); update(1,1,n,x,inf); for(int i=head[x];i;i=edge[i].next) if(dis[edge[i].to]&gt;dis[x]+edge[i].value) &#123; dis[edge[i].to]=dis[x]+edge[i].value; update(1,1,n,edge[i].to,dis[edge[i].to]); &#125; &#125; &#125; private: struct Node &#123; int value,from,to,next; &#125;edge[maxM+1]; int head[maxN+1],tot,sum[4*maxN+1]; bool vis[maxN+1]; void pushup(int k) &#123;sum[k]=min(sum[ls],sum[rs]);&#125;&#125;;int n,m,x,y,z;char map[maxQ+1][maxQ+1];algorithm task;void subtask();inline int read();int main()&#123; subtask(); return 0;&#125;void subtask()&#123; task.clear(); in(n); in(m); n++; m++; for(int i=1;i&lt;n;i++) scanf("%s",map[i]+1); for(int i=1;i&lt;n;i++) for(int j=1;j&lt;m;j++) if(map[i][j]==92) &#123; task.addtwo(i*m-m+j,i*m+j+1,0); task.addtwo(i*m-m+j+1,i*m+j,1); &#125; else &#123; task.addtwo(i*m-m+j,i*m+j+1,1); task.addtwo(i*m-m+j+1,i*m+j,0); &#125; task.dijkstra(1,n*m); if(task.dis[n*m]==0x3f3f3f3f) printf("NO SOLUTION\n"); else printf("%d\n",task.dis[n*m]);&#125;inline int read()&#123; char ch=getchar(); int num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') &#123;f=-1; ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123; num=num*10+ch-'0'; ch=getchar(); &#125; return num*f;&#125; 令人欣慰的绿色： 然而并没有（逃）普通线段树同学不够优秀（然而吸氧又过了），那当然是要用zkw线段树优化了（线段树：？？？），然后就又去借(chao)鉴(lai)了一下zkw线段树优化 $Dijkstra$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define ls x&lt;&lt;1#define rs x&lt;&lt;1|1#define in(x) x=read();using namespace std;const int maxN=500001,maxM=1000001;const int inf=0x7fffffff,maxQ=500;class algorithm&#123; public: int dis[maxN+1],ans[maxN+1]; inline void build(int size) &#123; for(leaf=1;leaf&lt;=size;leaf&lt;&lt;=1); leaf--; for(int i=1;i&lt;=size;++i) tree[leaf+i]=i; &#125; void update(int x,int y) &#123; dis[x]=y; x+=leaf; x&gt;&gt;=1; while(x) &#123; tree[x]=(dis[tree[ls]]&lt;dis[tree[rs]])?tree[ls]:tree[rs]; x&gt;&gt;=1; &#125; &#125; inline void addedge(int x,int y,int value) &#123; edge[++tot].from=x; edge[tot].to=y; edge[tot].value=value; edge[tot].next=head[x]; head[x]=tot; &#125; inline void addtwo(int x,int y,int value) &#123; addedge(x,y,value); addedge(y,x,value); &#125; inline void clear() &#123; memset(dis,0x3f,sizeof(dis)); memset(tree,0,sizeof(tree)); memset(ans,0x3f,sizeof(ans)); tot=0; &#125; void dijkstra(int s,int size) &#123; build(size); dis[s]=0; int x=s,dist; for(int i=1;i&lt;=size;++i) &#123; dist=ans[x]=dis[x]; update(x,inf); for(int i=head[x];i;i=edge[i].next) if(dis[edge[i].to]&lt;inf &amp;&amp; dis[edge[i].to]&gt;dist+edge[i].value) update(edge[i].to,dist+edge[i].value); x=tree[1]; &#125; &#125; private: struct Node &#123; int value,from,to,next; &#125;edge[maxM+1]; int head[maxN+1],tot,tree[maxN&lt;&lt;2],leaf;&#125;;int n,m,x,y,z;char map[maxQ+1][maxQ+1];algorithm task;void subtask();inline int read();int main()&#123; subtask(); return 0;&#125;void subtask()&#123; task.clear(); in(n); in(m); n++; m++; for(int i=1;i&lt;n;i++) scanf("%s",map[i]+1); for(int i=1;i&lt;n;i++) for(int j=1;j&lt;m;j++) if(map[i][j]==92) &#123; task.addtwo(i*m-m+j,i*m+j+1,0); task.addtwo(i*m-m+j+1,i*m+j,1); &#125; else &#123; task.addtwo(i*m-m+j,i*m+j+1,1); task.addtwo(i*m-m+j+1,i*m+j,0); &#125; task.dijkstra(1,n*m); if(task.ans[n*m]!=0x3f3f3f3f) printf("%d",task.ans[n*m]); else printf("NO SOLUTION");&#125;inline int read()&#123; char ch=getchar(); int num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') &#123;f=-1; ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123; num=num*10+ch-'0'; ch=getchar(); &#125; return num*f;&#125; 真 · 令人欣慰的绿色（无吸氧）： （后来看题解发现貌似手写堆也能过QWQ （太懒而不想写），卡常技术还有待提高啊）]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>zkw线段树</tag>
        <tag>堆</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1937 仓配置]]></title>
    <url>%2Fpassages%2F2019-04-07-P1937%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1937 仓配置题目描述： 如图，牛栏里只能容纳一定空间，进行线段覆盖，且覆盖数不能超过空间，求最大线段数12345678畜栏号: 1 2 3 4 5 +---+---+---+---+---+容纳空间: | 1 | 3 | 2 | 1 | 3 | +---+---+---+---+---+Cow 1 XXXXXXXXXXXXX (1, 3)Cow 2 XXXXXXXXXXXXXXXX (2, 5)Cow 3 XXXXXXXX (2, 3)Cow 4 XXXXXXXX (4, 5) 算法分析：考虑贪心：先让靠右的、占线段长度最小的入驻，这样就能避免覆盖中的重合问题。这样排序，然后用线段树维护当前区间剩余数量的最小值，若能入住 ($query&gt;0$) 就将空间减少 ($update$) 即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;algorithm&gt;#define rd int#define in(x) x=read()#define ls k&lt;&lt;1#define rs k&lt;&lt;1 | 1#define mid ((l+r)&gt;&gt;1)#define maxN 100010#define G ch=getchar()#define lson ls,l,mid#define rson rs,mid+1,r#define f(x,y) for(register int i=x;i&lt;=y;++i)#define q(x,y) tree.query(1,1,n,x,y,0)#define u(x,y) tree.update(1,1,n,x,y,-1),tot++#define S a[i].s#define T a[i].tusing namespace std;inline rd read();struct Query&#123; int s,t;&#125;a[maxN+1];class segment_tree&#123; public: void build(int k,int l,int r) &#123; if(l==r) &#123;in(sum[k]); return;&#125; build(lson); build(rson); pushup(k); &#125; void update(int k,int l,int r,int ql,int qr,int w) &#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;sum[k]+=w; v[k]+=w; return;&#125; if(v[k]) pushdown(k,l,r); if(ql&lt;=mid) update(lson,ql,qr,w); if(qr&gt;mid) update(rson,ql,qr,w); pushup(k); &#125; int query(int k,int l,int r,int ql,int qr,int w) &#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sum[k]; int ans=INT_MAX; if(v[k]) pushdown(k,l,r); if(ql&lt;=mid) ans=min(ans,query(lson,ql,qr,w)); if(qr&gt;mid) ans=min(ans,query(rson,ql,qr,w)); return ans; &#125; private: void pushup(int k) &#123;sum[k]=min(sum[ls],sum[rs]);&#125; void pushdown(int k,int l,int r) &#123; v[ls]+=v[k]; v[rs]+=v[k]; sum[ls]+=v[k]; sum[rs]+=v[k]; v[k]=0; &#125; int v[4*maxN+1],sum[4*maxN+1];&#125;;segment_tree tree;void subtask();int n,m,tot=0;bool comp(Query x,Query y) &#123;return (x.t!=y.t)?(x.t&lt;y.t):(x.s&gt;y.s);&#125;int main()&#123; subtask(); return 0;&#125;void subtask()&#123; in(n); in(m); tree.build(1,1,n); f(1,m) &#123;in(a[i].s); in(a[i].t);&#125; sort(a+1,a+m+1,comp); f(1,m) if(q(S,T)&gt;0) u(S,T); printf("%d",tot);&#125;inline rd read()&#123; rd num=0,f=1; char ch=getchar(); while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') G; if(ch=='-') &#123;f=-1; G;&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123;num=num*10+ch-'0'; G;&#125; return num*f;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化线段树——主席树]]></title>
    <url>%2Fpassages%2F2019-04-07-presi-tree%2F</url>
    <content type="text"><![CDATA[前言：最近心(po)血(yu)来(ya)潮(li)学习了一下主席树。（再不学就落伍了）主席树，即可持久化线段树，支持维护和查询区间的第$k$大（小）、区间不同种类个数等，基于线段树的思想 结构分析主席树会维护$[1,n]$中点的个数（可以理解为，一颗弹珠从树根放下，滑到叶节点时，走过的路径都$+1$）现在假设有一组数 $\{a_1,a_2,…,a_7\}$，离散化后编号为 $\{1,2,…,7\}$，现在以$\{1,7,6,2,3,5,4\}$的顺序进入主席树下面来演示一下这个过程（PowerPoint冠名）下面来张动图（PowerPoint冠名） 耐心等一会，总会等到GIF开头的（该动图时长32秒） 那么通过这种结构该如何寻找区间第$k$大（小）值呢？ 算法实现还是原来的数组 $\{1,7,6,2,3,5,4\}$，现在来举个栗子：求$2,5$这一段的第$2$小值（$3$）首先要了解这样一个概念：求区间第$k$小值，相当于在区间内找一个值，使有$k$个数小于等于这个值（废话）不(hen)难发现，在主席树里，左子树的值一定小于右子树的值。那么，只要判断左子树里的数的个数是否$\ge2$，如果是，那么区间第$2$小值一定在左子树里，反之在右子树里那么能否建$N$棵线段树呢？ MLE:小朋友，我来了！通过认真的观察，发现——这两张图中，真正修改了值的节点并不多。这时，两棵线段树完全可以使用共用的节点，这样就可以大大的降低空间复杂度。那么，该如何处理$[l,r]$中比当前值小的数的个数呢？这里就要用到二分和前缀和的思想了。举个栗子，如果$[1,l-1]$中有$sum_1$个数比当前值小，$[1,r]$中有$sum_2$个数比当前值小，那么$[l,r]$中就有 $sum_2-sum_1$个值比当前值小回到刚才的问题： 数组 $\{1,7,6,2,3,5,4\}$，求$2,5$这一段的第$2$小值（$3$） 我们挑出第$(2-1)$次插入时的树和第$5$次插入时的树，经过观察—— 你发现了什么？举个栗子，我们看上一棵树中的代表$[5,7]$的节点和下一棵树的对应节点，可以发现：它们的差就是$\{7,6,2,3\}$中在$[5,7]$上的数的个数。那么，上一棵树中的代表$[1,4]$的节点和下一棵树的对应节点之差为$2$，这说明第$2$小值必定在$[1,4]$区间内，由此即可求出第$2$小值——$3$ 代码实现$L,R$ 表示左右子树，$sum$ 就是图中所维护的维护$[1,n]$中点的个数，$rank$ 为离散化数组，$root$ 表示这么多线段树的根。答案递归求解即可。( $fm(x)$ 表示初始化 $x$ )12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define f(x,y) for(register int i=x;i&lt;=y;i++)#define G ch=getchar()#define rd int#define in(x) x=read();#define node int#define mid ((l+r)&gt;&gt;1)#define fm(x) memset(x,0,sizeof(x))#define maxN 200000using namespace std;inline rd read();class president_tree&#123; public: node query(int x,int y,int w) &#123;return rank[_query(root[x-1],root[y],1,_size,w)];&#125; void build(int a[],int n) &#123; tot=0; fm(rank); fm(root); fm(sum); fm(L); fm(R); for(register int i=1;i&lt;=n;i++) rank[i]=a[i]; sort(rank+1,rank+n+1); _size=unique(rank+1,rank+n+1)-rank-1; root[0]=_build(1,_size); for(register int i=1;i&lt;=n;i++) root[i]=update(root[i-1],1,_size,lower_bound(rank+1,rank+_size+1,a[i])-rank); &#125; private: int tot,_size; node rank[maxN+1],root[maxN+1],sum[(maxN&lt;&lt;5)+1],L[(maxN&lt;&lt;5)+1],R[(maxN&lt;&lt;5)+1];; node _build(int l,int r) &#123; int k=++tot; sum[k]=0; if(l&lt;r) &#123; L[k]=_build(l,mid); R[k]=_build(mid+1,r); &#125; return k; &#125; node update(int pre,int l,int r,int w) &#123; int k=++tot; L[k]=L[pre]; R[k]=R[pre]; sum[k]=sum[pre]+1; if(l&lt;r) if(w&lt;=mid) L[k]=update(L[pre],l,mid,w); else R[k]=update(R[pre],mid+1,r,w); return k; &#125; node _query(int u,int v,int l,int r,int k) &#123; if(l&gt;=r) return l; int w=sum[L[v]]-sum[L[u]]; if(w&gt;=k) return _query(L[u],L[v],l,mid,k); else return _query(R[u],R[v],mid+1,r,k-w); &#125;&#125;;int n,m,a[maxN+1],b[maxN+1],x,y,w;president_tree tree;int main()&#123; in(n); in(m); f(1,n) in(a[i]); tree.build(a,n); f(1,m) &#123; in(x); in(y); in(w); printf("%d\n",tree.query(x,y,w)); &#125; return 0;&#125;inline rd read()&#123; char ch=getchar(); rd num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') G; if(ch=='-') &#123;f=-1; G;&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123;num=num*10+ch-'0'; G;&#125; return num*f;&#125; 写在最后对主席树的认识与理解，到这篇博客的诞生，是起源于这两位巨佬的博客的——最详细的讲解，让你一次学会主席树【Notes】【主席树】hdu2665 Kth number在此表示衷心的感谢！（我才不会告诉你这篇博客写到一半未保存，网页就莫名其妙关闭了呢 QWQ）]]></content>
      <categories>
        <category>Models</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P3948 数据结构]]></title>
    <url>%2Fpassages%2F2019-04-07-P3948%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P3948 数据结构题目描述： 维护一个数组，使其能区间修改，并动态查询某区间内满足$min\leq(a_i\times i\ \%\ mod)\leq max$ 的数的个数 算法分析：该题操作共两个阶段——1、在线：要求动态修改，但数据量很小（$\leq 1000$），可以暴力查询，区间修改，单点查询2、离线：不要求动态修改，但数据量很大（$\leq 10000000$），可以预处理，然后区间查询如上，跑两个树状数组即可。事实证明，树状数组只能得72分，为了用数据结构（正解不用树状结构），吸个氧就过了（最大点490ms） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define node int#define maxN 80000#define in(x) x=read()using namespace std;class binary_tree&#123; public: inline node query(int x,int y) &#123;return (y+1)*sum(tree1,y)-sum(tree2,y)-x*sum(tree1,x-1)+sum(tree2,x-1);&#125; inline void build(node a[]) &#123;for(register int i=1;i&lt;=tot;i++) modify(i,a[i]-a[i-1]);&#125; inline void update(node x,node y,node k) &#123;modify(x,k); modify(y+1,-k);&#125; inline void clear(int n) &#123;tot=n; memset(tree1,0,sizeof(tree1)); memset(tree2,0,sizeof(tree2));&#125; private: node tree1[maxN+1],tree2[maxN+1],tot; inline node lowbit(node x) &#123;return x&amp;(-x);&#125; inline node sum(node a[],node x) &#123;node ans=0; while(x&gt;0) &#123;ans+=a[x]; x-=lowbit(x);&#125; return ans;&#125; inline void modify(node x,node k) &#123;for(register node i=x;i&lt;=tot;i+=lowbit(i)) &#123;tree1[i]+=k; tree2[i]+=k*x;&#125;&#125;&#125;;typedef int ll;ll l,r,k,read(); char s[2];int n,m,D,minT,maxT,check(int);binary_tree treeA,treeB;inline void task1(),task2();int main()&#123; task1(); task2(); return 0;&#125;inline int check(int x)&#123; ll now=treeA.query(x,x)%D; if(minT&lt;=((x*now)%D) &amp;&amp; ((x*now)%D)&lt;=maxT) return 1; return 0;&#125;inline void task1()&#123; in(n); in(m); in(D); in(minT); in(maxT); treeA.clear(n); for(register int i=1;i&lt;=m;i++) &#123; scanf("%s",s); in(l); in(r); if(s[0]=='A') treeA.update(l,r,read()); else &#123; ll ans=0; for(register int j=l;j&lt;=r;j++) ans+=check(j); printf("%d\n",ans); &#125; &#125;&#125;inline void task2()&#123; in(m); treeB.clear(n); for(register int i=1;i&lt;=n;i++) if(check(i)) treeB.update(i,i,1); for(register int i=1;i&lt;=m;i++) &#123; in(l); in(r); printf("%d\n",treeB.query(l,r)); &#125;&#125;inline ll read()&#123; ll num=0,f=1; char ch=getchar(); while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') &#123;f=-1; ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+ch-'0'; ch=getchar(); &#125; return num*f;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPOJ Can you answer these queries 系列]]></title>
    <url>%2Fpassages%2F2019-04-07-SPOJ-GSS%2F</url>
    <content type="text"><![CDATA[传送门I：Can you answer these queries III：Can you answer these queries IIIII：Can you answer these queries IIIIV：Can you answer these queries IVV：Can you answer these queries VVI：Can you answer these queries VIVII：Can you answer these queries VIIVIII：Can you answer these queries VIII 题目描述：I：区间最大子段和II：区间最大子段和（相同的数只算一次）III：支持单点修改的区间最大子段和IV：区间开平方运算，并区间求和V：查询左端点在$[x1,y1]$之间，且右端点在$[x2,y2]$之间的最大子段和VI：支持动态插入、删除、修改的区间最大子段和VII：在一棵树上，支持修改整条链的权值的链上最大子段和VIII：给定一个数列，支持如下操作： 插入一个数字在第$pos$个位置之前删除第$pos$个元素将第$pos$个元素变为val询问$(\sum_{i=l}^rA[i]\times(i-l+1)^k)\ mod\ 2^{32}$ 题解Can you answer these queries ICan you answer these queries I Can you answer these queries IICan you answer these queries II Can you answer these queries IIICan you answer these queries III Can you answer these queries IV传送门：Can you answer these queries IV重题：洛谷 P4145 上帝造题的七分钟2 / 花神游历各国题目描述：区间开平方运算，并区间求和算法分析：$\sqrt{x}$ 向下取整，那么$\forall x \in R$，在经过有限次开平方运算后，其结果一定为$1$。故只需将大于$1$的区间的数开平方即可，就能大大降低时间复杂度，然后在更新时只要递归修改即可（$10^{18}$至多需要6次修改），查询时区间查询。在这里用了两个数组：$sum$ 和 $maxi$，$sum$存储和，$maxi$储存区间最大值。若区间最大值 $&gt;1$，则需修改。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define G ch=getchar()#define in(x) x=read()using namespace std;typedef long long ll;inline ll read()&#123; char ch=getchar(); ll num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') G; if(ch=='-') &#123;f=-1; G;&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123;num=num*10+ch-'0'; G;&#125; return num*f;&#125;class segment_tree&#123; #define ls k&lt;&lt;1 #define rs k&lt;&lt;1 | 1 #define mid ((l+r)&gt;&gt;1) #define S(x) x=(int)sqrt(x) #define SIZE 100000 public: void clear() &#123;memset(sum,0,sizeof(sum)); memset(maxi,0,sizeof(maxi));&#125; void update(int k,int l,int r,int ql,int qr) &#123; if(l==r) &#123;S(sum[k]); S(maxi[k]); return;&#125; if(ql&lt;=mid &amp;&amp; maxi[ls]&gt;1) update(ls,l,mid,ql,qr); if(qr&gt;mid &amp;&amp; maxi[rs]&gt;1) update(rs,mid+1,r,ql,qr); pushup(k); &#125; ll query(int k,int l,int r,int ql,int qr) &#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sum[k]; ll ans=0; if(ql&lt;=mid) ans+=query(ls,l,mid,ql,qr); if(qr&gt;mid) ans+=query(rs,mid+1,r,ql,qr); return ans; &#125; void build(int k,int l,int r) &#123; if(l==r) &#123;in(sum[k]); maxi[k]=sum[k]; return;&#125; build(ls,l,mid); build(rs,mid+1,r); pushup(k); &#125; private: ll sum[4*SIZE+1],maxi[4*SIZE+1]; void pushup(int k) &#123;sum[k]=sum[ls]+sum[rs]; maxi[k]=max(maxi[ls],maxi[rs]);&#125; #undef ls #undef rs #undef mid #undef S&#125;;segment_tree tree;int n,m,l,r,op,t;void subtask(int);int main()&#123; while(~scanf("%d",&amp;n)) &#123;t++; subtask(t);&#125; return 0;&#125;void subtask(int _case)&#123; printf("Case #%d:\n",_case); tree.clear(); tree.build(1,1,n); in(m); for(register int i=1;i&lt;=m;i++) &#123; in(op); in(l); in(r); if(l&gt;r) swap(l,r); if(op==0) tree.update(1,1,n,l,r); else printf("%lld\n",tree.query(1,1,n,l,r)); &#125; printf("\n");&#125; Can you answer these queries VCan you answer these queries V Can you answer these queries VICan you answer these queries VI Can you answer these queries VIICan you answer these queries VII Can you answer these queries VIIICan you answer these queries VIII]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P4392 Sound 静音问题]]></title>
    <url>%2Fpassages%2F2019-04-07-P4392%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P4392 Sound 静音问题题目描述： 求数组区间最大（小） 算法分析：模板即可（然而调了半个小时——取最小值的时候忘记取最大值了QWQ） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define maxN 1000010#define ls k&lt;&lt;1#define rs k&lt;&lt;1 | 1#define mid ((l+r)&gt;&gt;1)#define node int#define in(x) x=read()using namespace std;inline int read()&#123; int num=0,f=1; char ch=getchar(); while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') &#123;f=-1; ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+ch-'0'; ch=getchar(); &#125; return num*f;&#125;class segment_tree&#123; public: node qmax(int l,int r) &#123;return query(sum1,1,1,1,tot,l,r);&#125; node qmin(int l,int r) &#123;return query(sum2,2,1,1,tot,l,r);&#125; void build(int k,int l,int r) &#123; if(l==r) &#123;in(sum1[k]); sum2[k]=sum1[k]; return;&#125; build(ls,l,mid); build(rs,mid+1,r); sum1[k]=max(sum1[ls],sum1[rs]); sum2[k]=min(sum2[ls],sum2[rs]); &#125; void clear(int n) &#123;memset(sum1,0,sizeof(sum1)); memset(sum2,0x3f,sizeof(sum2)); tot=n;&#125; private: node sum1[4*maxN+1],sum2[4*maxN+1]; int tot; node query(node sum[],int op,int k,int l,int r,int ql,int qr) &#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sum[k]; node maxT=0,minT=0x3f3f3f3f; if(ql&lt;=mid) maxT=minT=query(sum,op,ls,l,mid,ql,qr); if(op==1 &amp;&amp; qr&gt;mid) maxT=max(maxT,query(sum,op,rs,mid+1,r,ql,qr)); if(op==2 &amp;&amp; qr&gt;mid) minT=min(minT,query(sum,op,rs,mid+1,r,ql,qr)); return (op==1)?maxT:minT; &#125;&#125;;segment_tree tree;int n,m,c,f=1;int main()&#123; in(n); in(m); in(c); tree.clear(n); tree.build(1,1,n); for(int i=1;i&lt;=n-m+1;i++) if(tree.qmax(i,i+m-1)-tree.qmin(i,i+m-1)&lt;=c) &#123;printf("%d\n",i); f=0;&#125; if(f) printf("NONE"); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1487 失落的成绩单]]></title>
    <url>%2Fpassages%2F2019-04-07-P1487%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1487 失落的成绩单题目描述： 数列 $a$ 满足 A_i=\frac{A_{i-1}-A_{i+1}}{2}+d给出：首项 $A_1$、末项 $A_n$、$d$、$m$，求$A_m$ 算法分析：矩阵快速幂？还没学，所以我们就用数(mo)学(fa)来解决这道题。预备知识：特征方程 我们以这个式子为例—— $f_i=f_{i-1}+6f_{i-2}$首先我们来看两个数集 $A=\{x\mid x=(-2)^k,k\in\mathbb{N^}\}\ ,\ B=\{x\mid x=3^k,k\in\mathbb{N^}\}$ 那么，我们可以列出 $A$ 的前几项：$-2,4,-8,16,…$，$B$ 的前几项：$3,9,27,81,…$将 $A$ 代入递推式，神奇的发现—— f_1=-2f_2=4f_3=4+6\times(-2)=-8f_4=-8+6\times4=16......$A$ 中的数都满足上述的递推式，同样的，$B$ 也满足。很明显，$f_i=(-2)^k$ 和 $f_i=3^k$ 都是上述递推式的通项公式下面我们来看两个引理—— 1、若 $f_i=a^i$ 是某一递推式的通项公式，那么，$f_i=\lambda a^i$ 同样满足递推式（两边同乘上系数即可）2、若 $f_i=a^i$ 和 $f_i=b^i$ 都满足递推式，那么，$f_i=\alpha\times a^i+\beta\times b^i$ 同样满足（两式乘上系数相加即可） 接下来，我们来看一个经典的例子——斐波拉契数列 $f_i=f_{i-1}+f_{i-2}$现在我们不能像刚才那个式子“观察”出一个通解了，那么就需要我们自己进行构造（自己动手，丰衣足食）现在我们设存在一组等比数列满足这个递推式（不是等比怎么约分啊），其公比为 $q$ ，那么我们看一下这个式子—— f_i=f_{i-1}+f_{i-2}q^2\times f_{i-2}=q\times f_{i-2}+f_{i-2}q^2=q+1q^2-q-1=0这就是斐波拉契数列的特征方程把它解出来，可以得到—— $q_1=\frac{\sqrt5+1}{2},q_2=\frac{-\sqrt5+1}{2}$那么，我们就知道了——公比为$\frac{\pm\sqrt5+1}{2}$的等比数列满足斐波拉契数列那么，我们又知道了数列的前两项：$f_1=f_2=1$我们设 $f_i=\alpha\times(\frac{\sqrt5+1}{2})^i+\beta\times(\frac{-\sqrt5+1}{2})^i$，代入$f_1,f_2$则—— \begin{cases} \alpha(\frac{\sqrt5+1}{2})+\beta(\frac{-\sqrt5+1}{2})=f_1=1\\ \\ \alpha(\frac{\sqrt5+1}{2})^2+\beta(\frac{-\sqrt5+1}{2})^2=f_2=1\\ \end{cases}得 $\alpha=\frac{\sqrt5}{5},\beta=-\frac{\sqrt5}{5}$，这样，我们就求出了通项公式回到之前的递推数列——$f_i=f_{i-1}+6f_{i-2}$，怎么得出其通解的？其实很简单。我们设等比数列公比为 $q$，就可以得到特征方程—— $q^2-q-6=0 \Rightarrow q_1=-2,q_2=3$ 进入正题，首先来膜改一下式子： A_i=\frac{A_{i-1}-A_{i+1}}{2}+d2A_i=A_{i-1}-A_{i+1}+2dA_{i+1}=-2A_{i}+A_{i-1}+2d这是 $A$ 的递推式，我们将 $i$ 减 $1$： A_{i}=-2A_{i-1}+A_{i-2}+2d现在我们得出了答案 —— $A_{i}=-2A_{i-1}+A_{i-2}+2d$那么我们先将 $2d$ 放在一边，设数列 $a$ 满足 $a_{i}=-2a_{i-1}+a_{i-2}$设此数列公比为 $q$，现在代入—— q^2a_{i-2}=-2qa_{i-2}+a_{i-2}q^2+2q-1=0这就是上述递推式的特征方程现在解一下这个方程，可以得到—— $q_1=-\sqrt{2}-1,q_2=\sqrt{2}-1$那么我们就可以得到这个数列的通项公式—— a_i=\alpha(-\sqrt{2}-1)^i+\beta(\sqrt{2}-1)^i其中 $i\leq n$，并且 \begin{cases} \alpha(-\sqrt{2}-1)+\beta(\sqrt{2}-1)=a_1\\ \alpha(-\sqrt{2}-1)^n+\beta(\sqrt{2}-1)^n=a_n\\ \end{cases}将上面的方程解出来，我们可以得到—— \begin{cases} \alpha=\frac{a_1(\sqrt{2}-1)^{n-1}-a_n}{(-\sqrt{2}-1)(\sqrt{2}-1)^{n-1}-(-\sqrt{2}-1)^n}\\ \\ \beta=\frac{a_1(-\sqrt{2}-1)^{n-1}-a_n}{(\sqrt{2}-1)(-\sqrt{2}-1)^{n-1}-(\sqrt{2}-1)^n}\\ \end{cases}代入通项公式并整理—— a_m=\frac{a_n[(\sqrt{2}-1)^{m-1}-(-1)^{m-1}(\sqrt{2}+1)^{m-1}]+(-1)^{m-1}a_1[(\sqrt{2}-1)^{n-m}-(-\sqrt{2}-1)^{n-m}]}{(\sqrt{2}-1)^{n-1}-(-1)^{n-1}(\sqrt{2}+1)^{n-1}}设$f(x)=(\sqrt2-1)^x-(-1)^x(\sqrt2+1)^x$，可得 a_m=\frac{a_n\times f(m-1)+(-1)^{m-1}a_1\times f(n-m)}{f(n-1)}好了，现在是最后一个问题——还有$d$呢！其实很容(kun)易(nan)，观察递推式—— $A_i=-2A_{i-1}+A_{i-2}+2d$我们设 $A_i=a_i+p\times d$，代入—— A_i=-2A_{i-1}+A_{i-2}+2da_i+pd=-2a_{i-1}-2pd+a_{i-2}+pd+2d我们又有 $a_{i}=-2a_{i-1}+a_{i-2}$，那么两边约去，可得—— pd=-2pd+pd+2d \Rightarrow p=1故 $A_i=a_i+d$那么，根据题意，我们来膜改一下式子—— A_m=\frac{(A_n-d)\times f(m-1)+(-1)^{m-1}(A_1-d)\times f(n-m)}{f(n-1)}+d这样，我们就得到了数列的通项公式，代码就很好写了（没用龟(kuai)速幂，数据太弱QwQ） 123456789101112131415#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;const double p=sqrt(2)-1;int n,m; double d,a1,an;double c(int op) &#123;return (op&amp;1)?-1:1;&#125;double f(int x) &#123;return pow(p,x)-c(x)*pow(p+2,x);&#125;int main()&#123; scanf("%d%d%lf%lf%lf",&amp;n,&amp;m,&amp;d,&amp;a1,&amp;an); if(m==0) printf("0.000"); else printf("%.3lf",((an-d)*f(m-1)+c(m-1)*(a1-d)*f(n-m))/f(n-1)+d); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
</search>
