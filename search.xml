<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字符串算法——哈希与哈希表]]></title>
    <url>%2Fpassages%2F2019-05-15-hash%2F</url>
    <content type="text"><![CDATA[前言： 哈希算法，即通过函数来将字符串转化为一个数值，这个数值就称之为哈希值。利用哈希算法可以实现字符串问题的快速查找与匹配。 字符串哈希 哈希值的计算 对于字符串S=s1s2s3⋯smS=s_1s_2s_3\cdots s_mS=s​1​​s​2​​s​3​​⋯s​m​​，我们要计算其哈希值。为了便于计算，我们将每个字符对应到一个数上 设若函数 f(x)f(x)f(x)，一个字符xxx有且仅有唯一的f(x)f(x)f(x)与其对应 为何要定义这样的f(x)f(x)f(x)? 原因：对于不同的题目，会有全为大（小）写字母或混杂数字，此时的ASCIIASCIIASCII码是不连续的，我们就可以将计算范围缩小（当然，强制类型转换亦可） 例（原题含大写和小写字母和数字）： 123456int f(char ch)&#123; if(isupper(ch)) return ch-'A'+1; if(islower(ch)) return ch-'a'+27; if(isdigit(ch)) return ch-'0'+53;&#125; 我们定义这样一个函数： H(S)=(f(s_1)b^{m-1}+f(s_2)b^{m-2}+\cdots+f(s_m)b^0)\ \bmod\ h b指base，即进制，h为模数 其本质就是(f(s_1)f(s_2)f(s_3)\cdots f(s_m))_{b}\ \bmod\ h，故也可称之为进制哈希 举个栗子：字符串 S=BCABS=BCABS=BCAB，f(A)=1,f(B)=2,f(C)=3,base=3,h=47f(A)=1,f(B)=2,f(C)=3,base=3,h=47f(A)=1,f(B)=2,f(C)=3,base=3,h=47 则 H(S)=(2\times3^3+3\times3^2+1\times3^1+2\times3^0)\ \bmod\ 47=86\ \bmod\ 47=39 哈希匹配问题 现在有了这个函数，我们来考虑字符串的匹配问题 举个栗子：字符串 A=abcdbcacA=abcdbcacA=abcdbcac ，字符串 B=bcaB=bcaB=bca , 判断 AAA 的一段子串是否与 BBB 匹配 先考虑朴素算法——每一次枚举 AAA 中子串的开始位置，逐个与 BBB 尝试匹配，这时的时间复杂度是 O(NM)O(NM)O(NM) ，其中 NNN是主串长度，MMM是子串长度 现在我们利用哈希算法来进行匹配——每次计算 AAA 中某一段的哈希值，与 BBB 的哈希值相比较 那么如何计算某一段的哈希值呢？ 我们可以得到 H′(Sub)=H(k+len)−H(k)×blenH&#x27;(Sub)=H(k+len)-H(k)\times b^{len} H​′​​(Sub)=H(k+len)−H(k)×b​len​​ 其中字符串 S=s1s2s3⋯smS=s_1s_2s_3\cdots s_mS=s​1​​s​2​​s​3​​⋯s​m​​，从 k+1k+1k+1 位开始的长度为 lenlenlen 的子串 Sub=sk+1sk+2sk+3⋯sk+lenSub=s_{k+1}s_{k+2}s_{k+3}\cdots s_{k+len}Sub=s​k+1​​s​k+2​​s​k+3​​⋯s​k+len​​，H(x)H(x)H(x) 表示 SSS 的哈希函数，H′(x)H&#x27;(x)H​′​​(x) 表示 SSS 的哈希函数 那么只要预处理H(x)H(x)H(x) 和 bxb^xb​x​​ 就能实现 O(1)O(1)O(1) 计算子串哈希 这样字符串匹配问题的时间复杂度就是 O(N+M)O(N+M)O(N+M) 当然，KMPKMPKMP 算法也可以解决匹配问题，速度更快，但哈希的适用性更广 某一字符串的哈希值计算： 前面，我们定义 H(x)H(x)H(x) 为 SSS 的哈希函数，其实其本质就是相当于一个前缀和，表示序号为111到xxx组成的字符串的哈希值 如字符串 S=BCABS=BCABS=BCAB，f(A)=1,f(B)=2,f(C)=3,base=3,h=47f(A)=1,f(B)=2,f(C)=3,base=3,h=47f(A)=1,f(B)=2,f(C)=3,base=3,h=47 则 H(3)=(2\times3^2+3\times3^1+1\times3^0)\ \bmod\ 47 那么计算时我们就可以用秦九韶算法 当然，对于懒癌患者，我们不知道unsigned long long能自然溢出，即对2642^{64}2​64​​取模，就省去了手动取模 以下为 H(x)H(x)H(x) 的计算方法 123h[0]=0;for(register int i=1;i&lt;=m;i++) h[i]=(h[i-1]*b+f(s[i]))%mod; 代码实现 一、子串查找（LOJ） 给定两个字符串，求子串在主串中的出现次数 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxN=1000000;typedef unsigned long long ull;ull mul[maxN+1],h[maxN+1],b=53;//mul:表示b的幂//h:哈希函数//b:base，进制char s2[maxN+1],s1[maxN+1];int n,m,ans=0;ull f(char ch)&#123; if(isupper(ch)) return ch-'A'+1; if(islower(ch)) return ch-'a'+27;&#125;int main()&#123; mul[0]=1; scanf("%s%s",s1+1,s2+1); for(register int i=1;i&lt;maxN;i++) mul[i]=mul[i-1]*b; n=strlen(s2+1); m=strlen(s1+1); h[0]=0; for(register int i=1;i&lt;=m;i++) h[i]=h[i-1]*b+f(s1[i]); ull s=0; for(register int i=1;i&lt;=n;i++) s=s*b+f(s2[i]); for(register int i=0;i&lt;=m-n;i++) if(s==h[i+n]-h[i]*mul[n]) ans++; printf("%d",ans); return 0;&#125; 二、【模板】字符串哈希（洛谷） 判断相同字符串个数 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int maxN=10000;long long mod=1e9+7,x=89;long long a[maxN+1];char s[1600];int n,tot=0;int f(char ch)&#123; if(isupper(ch)) return ch-'A'+1; if(islower(ch)) return ch-'a'+27; if(isdigit(ch)) return ch-'0'+53;&#125;long long h(char s[])&#123; int len=strlen(s); long long h=0; for(register int i=0;i&lt;len;i++) h=(h*x+f(s[i]))%mod; return h;&#125;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;i++) &#123;scanf("%s",s); a[i]=h(s);&#125; sort(a+1,a+n+1); for(register int i=1;i&lt;=n;i++) if(a[i]!=a[i-1]) tot++; printf("%d",tot); return 0;&#125; 存在的问题 回到先前的例子 字符串 S=BCABS=BCABS=BCAB，f(A)=1,f(B)=2,f(C)=3,base=3,h=47f(A)=1,f(B)=2,f(C)=3,base=3,h=47f(A)=1,f(B)=2,f(C)=3,base=3,h=47 则 H(S)=(2\times3^3+3\times3^2+1\times3^1+2\times3^0)\ \bmod\ 47=86\ \bmod\ 47=39 看上去并没有什么问题，但其实隐藏着巨大的隐患： 我们看字符串 S′=AABBAS&#x27;=AABBAS​′​​=AABBA H(S')=(1\times3^4+1\times3^3+2\times3^2+2\times3^1+1\times3^0)\ \bmod\ 47=133\ \bmod\ 47=39 此时我们的哈希值就出现了重复：H(S)=H(S′)H(S)=H(S&#x27;)H(S)=H(S​′​​) ，但S\not= S' 主要方式就是加大模数，扩大哈希值的范围，由此尽量减少重复次数；再或是利用多次哈希得到多个哈希值来确定一个字符串（一般为双哈希） 若取用上述办法，会导致哈希数组的跨越过大，拖慢搜寻速度，因此，我们引入哈希表——尽量减小模数，将重复的放进链表 哈希表]]></content>
      <categories>
        <category>Models</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做题计划]]></title>
    <url>%2Fpassages%2F%E5%81%9A%E9%A2%98%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[队列： P2253 好一个一中腰鼓！ （线段树 绿题） P3939 数颜色 （线段树 蓝题） P3919 【模板】可持久化数组（可持久化线段树/平衡树） （模板 蓝题） P4188 [USACO18JAN]Lifeguards S （线段树 蓝题） P2982 [USACO10FEB]慢下来Slowing down （线段树 蓝题） P1904 天际线 （线段树 蓝题） P1637 三元上升子序列 （线段树 蓝题） P4879 ycz的妹子 （线段树 蓝题） P4969 神秘的703 （线段树 蓝题） P3801 红色的幻想乡 （线段树 蓝题） P3932 浮游大陆的68号岛 （线段树/前缀和 蓝题） P4422 [COCI2017-2018#1] Deda （线段树 蓝题） P2471 [SCOI2007]降雨量 （线段树 紫题） P1712 [NOI2016]区间 （线段树 紫题） P3899 [湖南集训]谈笑风生 （主席树 紫题） P3391 【模板】文艺平衡树（Splay） （模板 紫题） P1502 窗口的星星 （线段树 紫题） CF558E A Simple Task （线段树 紫题） [CF787D 遗产] P1486 [NOI2004]郁闷的出纳员 （平衡树 紫题） P1118 [USACO06FEB]数字三角形 （搜索 黄题） P1825 [USACO11OPEN]玉米田迷宫Corn Maze （搜索 绿题）24分 P1083 借教室 （二分 蓝题） P1201 [USACO1.1]贪婪的送礼者Greedy Gift Givers （USACO专题 橙题） P1080 国王游戏 （贪心 蓝题） P1197 [JSOI2008]星球大战 或 P1196 [NOI2002]银河英雄传说 （并查集 蓝题） P1113 杂务（图论 黄题） P1983 车站分级 （图论 黄题） P1338 末日的传说 （数论 黄题） P1108 低价购买 （DP 蓝题） P1582 倒水 （数论 绿题） P1220 关路灯 （DP 绿题） P1373 小a和uim之大逃离 （DP 蓝题） P2279 [HNOI2003]消防局的设立 （搜索 蓝题） P1070 道路游戏 （DP 蓝题） CF940E Cashback（DP 蓝题） P2123 皇后游戏 （贪心 紫题） CF721E Road to Home （DP 灰题） CF939F Cutlet （DP 黑题）]]></content>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 141B Hopscotch]]></title>
    <url>%2Fpassages%2F2019-04-29-CF141B%2F</url>
    <content type="text"><![CDATA[传送门：CF141B Hopscotch 题目描述： 有nnn个形状和大小都一致的正方体积木，积木堆积的样式是第一层只有一个正方体，然后上面就开始循环了，循环体为：第一层是一个正方体，第二层是两个正方体。如下图所示： 现在给你三个数，表示正方体的边长，然后让你输出坐标(x,y)(x,y)(x,y)对应的数。如果在积木的边界上或者是不在正方体上输出−1-1−1。 算法分析： 判断是否在边界上（a∣ya|ya∣y），是否在第一、二象限(y&gt;0y&gt;0y&gt;0) 接着，判断 yyy 是否比 aaa 小，xxx是否在第一个正方形内 将yyy减去aaa（删去第一层），dir=y2a+1dir=\frac{y}{2a}+1dir=​2a​​y​​+1 表示其所在的层数 然后就可以得到当前可能位置下的个数 bottom=(dir−1)∗3+2bottom=(dir-1)*3+2bottom=(dir−1)∗3+2 ，并把可能位置以下的层数减去 最后再做一遍第一步的判断 时间复杂度：O(1)O(1)O(1) 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int a,y; double x;void work();int main()&#123; cin&gt;&gt;a&gt;&gt;x&gt;&gt;y; if(y%a==0 || y&lt;=0) printf("-1"); else work(); return 0;&#125;void work()&#123; if(y&gt;0 &amp;&amp; y&lt;a &amp;&amp; x&gt;-a*1.0/2 &amp;&amp; x&lt;a*1.0/2) &#123;printf("1"); return;&#125; y-=a; int dir=y/(2*a)+1; int bottom=(dir-1)*3+2; y-=(dir-1)*2*a; if(y&gt;0 &amp;&amp; y&lt;a) if(x&gt;-a*1.0/2 &amp;&amp; x&lt;a*1.0/2) &#123; printf("%d",bottom); return; &#125; if(y&gt;a &amp;&amp; y&lt;a*2) &#123; if(x==0) &#123;printf("-1"); return;&#125; if(x&gt;-a &amp;&amp; x&lt;0) &#123; printf("%d",bottom+1); return; &#125; else if(x&gt;0 &amp;&amp; x&lt;a) &#123; printf("%d",bottom+2); return; &#125; &#125; printf("-1");&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>平面几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1018 乘积最大]]></title>
    <url>%2Fpassages%2F2019-04-29-P1018%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1018 乘积最大 算法分析： 首先，算法主体为区间DP，设 f[i][j]f[i][j]f[i][j] 为在中分i个乘号的最大结果 则 f[i][j]=max{f[i][j],f[i−1][t]×a[t+1][j]}f[i][j]=max\{f[i][j],f[i-1][t]\times a[t+1][j]\}f[i][j]=max{f[i][j],f[i−1][t]×a[t+1][j]} 其中 i∈[1,k]i\in[1,k]i∈[1,k] , j∈[i+1,n]j\in[i+1,n]j∈[i+1,n] , t∈[i,j)t\in[i,j)t∈[i,j) , aaa 中存储所有拆分数 考虑到本题的数据量，使用高精度乘法计算 高精度乘法实现： 分为5个函数： remix ：将数组中的数右对齐 give ：将数组中的内容拷贝到另一个数组中 write ：去前导0并输出 comp ：比较函数 multi ：进行竖式运算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef unsigned long long ull;const int maxN=100;struct Node&#123; int num[maxN+1];&#125;;int n,k,a[maxN+1],b[maxN+1],c[maxN+1];char s[maxN+1];Node dp[maxN+1][maxN+1];ull a1[maxN+1][maxN+1];void remix(int[],ull),reset(),DP();void multi(int[],int[]);void give(int[],int[]),write();int comp(int[],int[]);int main()&#123; reset(); DP(); write(); return 0;&#125;void remix(int a[],ull num)&#123; int len=0,lent=0; ull temp=num; while(num) &#123;lent++; num/=10;&#125; len=lent; while(temp) &#123;a[--lent]=temp%10; temp/=10;&#125; for(int i=maxN;i&gt;=0;i--,len--) if(len&gt;0) a[i]=a[len-1]; else a[i]=0;&#125;void reset()&#123; scanf("%d%d%s",&amp;n,&amp;k,s); memset(a1,0,sizeof(a1)); for(int i=0;i&lt;n;i++) for(int j=i;j&lt;n;j++) a1[i+1][j+1]=a1[i+1][j]*10+s[j]-'0'; for(int i=0;i&lt;=n;i++) remix(dp[0][i].num,a1[1][i]);&#125;void DP()&#123; for(int i=1;i&lt;=k;i++) for(int j=i+1;j&lt;=n;j++) &#123; memset(dp[i][j].num,0,sizeof(dp[i][j].num)); for(int t=i;t&lt;j;t++) &#123; memset(c,0,sizeof(c)); int now[maxN+1]=&#123;0&#125;; remix(now,a1[t+1][j]); multi(dp[i-1][t].num,now); if(comp(dp[i][j].num,c)==-1) give(dp[i][j].num,c); &#125; &#125;&#125;void write()&#123; int i=0; while(i&lt;maxN &amp;&amp; dp[k][n].num[i]==0) i++; while(i&lt;=maxN) printf("%d",dp[k][n].num[i++]);&#125;void multi(int a[],int b[])&#123; int jw,t; for(int i=maxN;i&gt;maxN/2;i--) &#123; jw=0; t=i; for(int j=maxN;j&gt;maxN/2;j--) &#123; c[t]+=a[i]*b[j]+jw; jw=c[t]/10; c[t--]%=10; &#125; c[t--]=jw; &#125;&#125;int comp(int a[],int b[])&#123; int len1=0,len2=0; while(a[len1]==0) len1++; while(b[len2]==0) len2++; if(len1&lt;len2) return 1; if(len1&gt;len2) return -1; for(;len1&lt;=maxN;len1++) &#123; if(a[len1]&lt;b[len1]) return -1; if(a[len1]&gt;b[len1]) return 1; &#125; return 0;&#125;void give(int change[],int own[])&#123; for(int i=0;i&lt;=maxN;i++) change[i]=own[i];&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
        <tag>高精</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P3146 248]]></title>
    <url>%2Fpassages%2F2019-04-29-P3146%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P3146 248 算法分析： 设 f[i][j]f[i][j]f[i][j] 为合并 i−ji-ji−j 位的最大数字，那么满足 f[i][k−1]==f[k][j]f[i][k-1]==f[k][j]f[i][k−1]==f[k][j] （即判断前一段的值能否和后一段的再次合并）时，f[i][j]=max(f[i][j],f[i][k−1]+1)f[i][j]=max(f[i][j],f[i][k-1]+1)f[i][j]=max(f[i][j],f[i][k−1]+1)（合并后的值+1+1+1），最后取最佳值（枚举 f[i][j]f[i][j]f[i][j] ） 时间复杂度：O(n3)O(n^3)O(n​3​​) 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxN=248;int n,dp[maxN+1][maxN+1],ans=0;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;dp[i][i]); for(int i=n-1;i&gt;=1;i--) for(int j=i+1;j&lt;=n;j++) for(int k=i-1;k&lt;=j;k++) if(dp[i][k-1]==dp[k][j]) dp[i][j]=max(dp[i][j],dp[i][k-1]+1); for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j++) ans=max(ans,dp[i][j]); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1006 传纸条]]></title>
    <url>%2Fpassages%2F2019-04-29-P1006%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1006 传纸条 算法分析： 首先想到两张纸条同时传，则是四维DP，转移方程如下： dp[i][j][l][r]=max{dp[i−1][j][l−1][r],dp[i−1][j][l][r−1],dp[i][j−1][l−1][r],dp[i][j−1][l][r−1]}+a[i][j]+a[l][r]dp[i][j][l][r]=max\{dp[i-1][j][l-1][r],dp[i-1][j][l][r-1],dp[i][j-1][l-1][r],dp[i][j-1][l][r-1]\}+a[i][j]+a[l][r] dp[i][j][l][r]=max{dp[i−1][j][l−1][r],dp[i−1][j][l][r−1],dp[i][j−1][l−1][r],dp[i][j−1][l][r−1]}+a[i][j]+a[l][r] 表示分两条路径传播 变形：洛谷 P1004 方格取数 时间复杂度：O(n4)O(n^4)O(n​4​​) 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxN=50;int m,n,a[maxN+1][maxN+1];int dp[maxN+1][maxN+1][maxN+1][maxN+1];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int l=1;l&lt;=n;l++) for(int r=j+1;r&lt;=m;r++) dp[i][j][l][r]=max(dp[i-1][j][l-1][r],max(dp[i-1][j][l][r-1],max(dp[i][j-1][l-1][r],dp[i][j-1][l][r-1])))+a[i][j]+a[l][r]; printf("%d",dp[n][m-1][n-1][m]); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>多维DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1044 栈]]></title>
    <url>%2Fpassages%2F2019-04-29-P1044%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1044 栈 算法分析：卡特兰数（传送门：卡特兰数） C_n=C_0\times C_{n-1}+C_1\times C_{n-2}+…+C_{n-1}\times C_0 时间复杂度 O(n2)O(n^2)O(n​2​​) 123456789101112131415#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxN=18;int n,h[maxN+1];int main()&#123; scanf("%d",&amp;n); h[0]=h[1]=1; for(int i=2;i&lt;=n;i++) for(int j=0;j&lt;i;j++) h[i]+=h[j]*h[n-1-i]; printf("%d",h[n]); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1725 琪露诺]]></title>
    <url>%2Fpassages%2F2019-04-29-P1725%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1725 琪露诺 算法分析： 设 dp[i]dp[i]dp[i] 为走到i位置的最大价值，则 dp[i]=max(dp[i],dp[i−j]+a[i])dp[i]=max(dp[i],dp[i-j]+a[i])dp[i]=max(dp[i],dp[i−j]+a[i]) , 其中i∈[l,n]i\in[l,n]i∈[l,n]，j∈[l,r]j\in[l,r]j∈[l,r] 最后答案即为 max{dp[i]}max\{dp[i]\}max{dp[i]}，其中i∈[n−r+1,n]i\in[n-r+1,n]i∈[n−r+1,n] 此方法时间复杂度为 O(n2)O(n^2)O(n​2​​) ，对于 maxN=2×105maxN=2\times10^5maxN=2×10​5​​ 是超出的 再观察该方程，其中 dp[i],a[i]dp[i],a[i]dp[i],a[i] 为定值，只要求在i∈[l,n]i\in[l,n]i∈[l,n]，j∈[l,r]j\in[l,r]j∈[l,r] 区间中 dp[i−j]dp[i-j]dp[i−j] 的最大值，使用单调队列算法来优化 时间复杂度：O(n)O(n)O(n) 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxN=200000;int a[maxN+1],dp[maxN+10],q[maxN+1];int n,l,r,ans=0,q_head,q_tail,num[maxN+1];inline int read();int main()&#123; n=read(); l=read(); r=read(); for(int i=0;i&lt;=n;i++) a[i]=read(); q_head=1; q_tail=0; for(int i=l;i&lt;=n;i++) &#123; while(dp[i-l]&gt;=q[q_tail] &amp;&amp; q_head&lt;=q_tail) q_tail--; num[++q_tail]=i-l; q[q_tail]=dp[i-l]; while(i-num[q_head]&gt;r-l) q_head++; dp[i]=q[q_head]+a[i]; &#125; for(int i=n-r+1;i&lt;=n;i++) ans=max(ans,dp[i]); printf("%d",ans); return 0;&#125;inline int read()&#123; char ch=getchar(); int num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') &#123;f=-1; ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123; num=num*10+ch-'0'; ch=getchar(); &#125; return num*f;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1043 数字游戏]]></title>
    <url>%2Fpassages%2F2019-04-08-P1043%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1043 数字游戏 题目描述： 有这样一个游戏：在你面前有一圈整数（一共nnn个），你要按顺序将其分为mmm个部分，各部分内的数字相加，相加所得的mmm个结果对101010取模后再相乘，最终得到一个数kkk。游戏的要求是使你所得的kkk最大或者最小。 例如，对于下面这圈数字（n=4,m=2n=4,m=2n=4,m=2）： 要求最小值时，((2−1)\ mod\ 10)\times((4+3)\ mod\ 10)=1×7=7，要求最大值时，((2+4+3)\ mod\ 10)×(−1\ mod\ 10)=9×9=81。特别值得注意的是，无论是负数还是正数，对101010取模的结果均为非负值。 算法分析： 首先，这张图是一个环的形式，题目大意是要对任意一段求和，故使用前缀和算法，并将数据重复储存来把环破开成链。 其次，这道题用区间DP，以最大值为例： 设 dp[i][j][t]dp[i][j][t]dp[i][j][t] 为从 iii 到 jjj 中分为 ttt 部分所得的最大价值，则 dp[i][j][t]=max(dp[i][j][t],dp2[i][k−1][t−1]∗(a[j]−a[k−1])%10)dp[i][j][t] = max(dp[i][j][t],dp2[i][k-1][t-1]*(a[j]-a[k-1])\%10)dp[i][j][t]=max(dp[i][j][t],dp2[i][k−1][t−1]∗(a[j]−a[k−1])%10) 其中 ttt 从 222 到 mmm ， iii 从 111 到 2n2n2n（环破成链），jjj 从 i+t−1i+t-1i+t−1（从 iii 开始的 ttt 个数）到 2n2n2n。 每次将 dp1dp_1dp​1​​（求最小值）设为 infinfinf，枚举区间 kkk，最后枚举开始位，求取 nnn 位并分割 mmm 次中的最大（小）值。 时间复杂度 O(mn3)O(mn^3)O(mn​3​​) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxN=100,maxM=9,inf=2147483647;int dp1[maxN+1][maxN+1][maxM+1];int dp2[maxN+1][maxN+1][maxM+1];int n,m,a[maxN+1];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); a[n+i]=a[i]; &#125; n*=2; for(int i=2;i&lt;=n;i++) a[i]+=a[i-1]; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j++) dp1[i][j][1]=dp2[i][j][1]=((a[j]-a[i-1])%10+10)%10; for(int t=2;t&lt;=m;t++) for(int i=1;i&lt;=n;i++) for(int j=i+t-1;j&lt;=n;j++) &#123; dp1[i][j][t]=inf; for(int k=i+t-1;k&lt;=j;k++) &#123; int temp=((a[j]-a[k-1])%10+10)%10; dp1[i][j][t]=min(dp1[i][j][t],dp1[i][k-1][t-1]*temp); dp2[i][j][t]=max(dp2[i][j][t],dp2[i][k-1][t-1]*temp); &#125; &#125; n/=2; int maxT=0,minT=inf; for(int i=1;i&lt;=n;i++) &#123; maxT=max(dp2[i][i+n-1][m],maxT); minT=min(dp1[i][i+n-1][m],minT); &#125; printf("%d\n%d",minT,maxT); getchar(); getchar(); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P2347 砝码称重]]></title>
    <url>%2Fpassages%2F2019-04-08-P2347%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P2347 砝码称重 题目描述： 设有1g1g1g、2g2g2g、3g3g3g、5g5g5g、10g10g10g、20g20g20g的砝码各若干枚（其总重≤1000\leq1000≤1000），求用这些砝码能称出的不同重量的个数。 算法分析：两重循环枚举所用砝码 时间复杂度 O(maxT×maxM×maxN)O(maxT\times maxM \times maxN)O(maxT×maxM×maxN) 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxM=1000;const int w[7]=&#123;0,1,2,3,5,10,20&#125;;int box[maxM+1],num[7],sum=0;int main()&#123; box[0]=1; for(int i=1;i&lt;=6;i++) scanf("%d",&amp;num[i]); for(int i=1;i&lt;=6;i++) for(int j=1;j&lt;=num[i];j++) for(int k=maxM;k&gt;=0;k--) if(k+w[i]&lt;=maxM &amp;&amp; box[k]) box[k+w[i]]=1; for(int i=1;i&lt;=maxM;i++) if(box[i]) sum++; printf("Total=%d",sum); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P4145 上帝造题的七分钟2 / 花神游历各国]]></title>
    <url>%2Fpassages%2F2019-04-07-P4145%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P4145 上帝造题的七分钟2 / 花神游历各国 题目描述： 将区间内的每个数开平方，并区间求和 算法分析：x\sqrt{x}√​x​​​ 向下取整，那么∀x∈R\forall x \in R∀x∈R，在经过有限次开平方运算后，其结果一定为111。故只需将大于111的区间的数开平方即可，就能大大降低时间复杂度，然后在更新时只要递归修改即可（101210^{12}10​12​​至多需要6次修改），查询时区间查询。在这里用了两个数组：sumsumsum 和 maximaximaxi，sumsumsum存储和，maximaximaxi储存区间最大值。若区间最大值 &gt;1&gt;1&gt;1，则需修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#define ls k&lt;&lt;1#define rs k&lt;&lt;1 | 1#define mid ((l+r)&gt;&gt;1)#define G ch=getchar()#define in(x) x=read()#define S(x) x=(int)sqrt(x)using namespace std;const int maxN=100000;typedef long long rd;typedef long long ll;inline rd read();int n,m,l,r,op;ll sum[4*maxN+1],maxi[4*maxN+1];void update(int,int,int,int,int);ll query(int,int,int,int,int);void build(int,int,int),pushup(int);int main()&#123; in(n); build(1,1,n); in(m); for(register int i=1;i&lt;=m;i++) &#123; in(op); in(l); in(r); if(l&gt;r) swap(l,r); if(op==0) update(1,1,n,l,r); else printf("%lld\n",query(1,1,n,l,r)); &#125; return 0;&#125;void pushup(int k)&#123; sum[k]=sum[ls]+sum[rs]; maxi[k]=max(maxi[ls],maxi[rs]);&#125;void update(int k,int l,int r,int ql,int qr)&#123; if(l==r) &#123;S(sum[k]); S(maxi[k]); return;&#125; if(ql&lt;=mid &amp;&amp; maxi[ls]&gt;1) update(ls,l,mid,ql,qr); if(qr&gt;mid &amp;&amp; maxi[rs]&gt;1) update(rs,mid+1,r,ql,qr); pushup(k);&#125;ll query(int k,int l,int r,int ql,int qr)&#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sum[k]; ll ans=0; if(ql&lt;=mid) ans+=query(ls,l,mid,ql,qr); if(qr&gt;mid) ans+=query(rs,mid+1,r,ql,qr); return ans;&#125;void build(int k,int l,int r)&#123; if(l==r) &#123;in(sum[k]); maxi[k]=sum[k]; return;&#125; build(ls,l,mid); build(rs,mid+1,r); pushup(k);&#125;inline rd read()&#123; char ch=getchar(); rd num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') G; if(ch=='-') &#123;f=-1; G;&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123;num=num*10+ch-'0'; G;&#125; return num*f;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1095 守望者的逃离]]></title>
    <url>%2Fpassages%2F2019-04-07-P1095%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1095 守望者的逃离 题目描述： 恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。守望者的跑步速度为17m/s17m/s17m/s，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s1s1s内移动60m60m60m，不过每次使用闪烁法术都会消耗魔法值101010点。守望者的魔法值恢复的速度为444点/s/s/s，只有处在原地休息状态时才能恢复。 现在已知守望者的魔法初值MMM，他所在的初始位置与岛的出口之间的距离SSS，岛沉没的时间TTT。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意：守望者跑步、闪烁或休息活动均以秒(s)(s)(s)为单位，且每次活动的持续时间为整数秒。距离的单位为米(m)(m)(m)。 算法分析：分两种情况： 1、运用贪心，尽可能用闪烁法术 2、枚举秒数，判断此时用跑步速度是否能获得更大收益 时间复杂度：O(t)O(t)O(t) 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxT=300000;int t,m,s,dp[maxT+1],ans=0;int main()&#123; scanf("%d%d%d",&amp;m,&amp;s,&amp;t); for(int i=1;i&lt;=t;i++) &#123; if(m&gt;=10) &#123;dp[i]=dp[i-1]+60; m-=10;&#125; else &#123;dp[i]=dp[i-1]; m+=4;&#125; &#125; for(int i=1;i&lt;=t;i++) &#123; dp[i]=max(dp[i],dp[i-1]+17); if(dp[i]&gt;=s) &#123;ans=i; break;&#125; &#125; if(ans) printf("%d",ans); else printf("%d",dp[s]); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P4667 Switch the Lamp On]]></title>
    <url>%2Fpassages%2F2019-04-07-P4667%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P4667 Switch the Lamp On 重题（弱化版）：洛谷 P2243 电路维修 题目描述： 每条电线可旋转 90∘90^\circ90​∘​​指向另一方向，则求从左上角到右下角最少要旋转的次数 算法分析： 前言：为了测试算法速度，本题没有谜の卡常 BFS ?BFS\ ?BFS ? ~~貌似对我这样的蒟蒻不太友好。~~该题本质上是沿对角线有一条路径，只不过其中顺着原电线方向的权值为000，反之为111，这样跑一遍DijkstraDijkstraDijkstra即可。（自从过于不友好的 P4779 单源最短路径（标准版）后就转用DijkstraDijkstraDijkstra）果断套堆优化模板—— 突然发现：N*M=250000 ??? 那前面的WAWAWA呢？经过深思熟虑，突然发现：对角线的连线是N∗MN*MN∗M，这就意味着图是以点的形式呈现时，应是(N+1)×(M+1)(N+1)\times(M+1)(N+1)×(M+1)，果断套堆优化模板（第一次用classclassclass还有点小激动）—— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#define in(x) x=read();using namespace std;const int maxN=1000001,maxM=1000001,maxQ=500;class algorithm&#123; public: int dis[maxN+1]; void addedge(int x,int y,int value) &#123; tot++; edge[tot].from=x; edge[tot].to=y; edge[tot].value=value; edge[tot].next=head[x]; head[x]=tot; &#125; void addtwo(int x,int y,int value) &#123; addedge(x,y,value); addedge(y,x,value); &#125; void clear() &#123; memset(dis,0x3f,sizeof(dis)); memset(vis,false,sizeof(vis)); memset(head,0,sizeof(head)); tot=0; &#125; void dijkstra(int s) &#123; dis[s]=0; q.push(make_pair(0,s)); while(q.size()) &#123; int x=q.top().second; q.pop(); if(vis[x]) continue; vis[x]=true; for(int i=head[x];i;i=edge[i].next) &#123; if(dis[edge[i].to]&gt;dis[x]+edge[i].value) &#123; dis[edge[i].to]=dis[x]+edge[i].value; q.push(make_pair(-dis[edge[i].to],edge[i].to)); &#125; &#125; &#125; &#125; private: struct Node &#123; int value,from,to,next; &#125;edge[maxM+1]; int head[maxN+1],tot; bool vis[maxN+1]; priority_queue&lt;pair&lt;int,int&gt; &gt; q;&#125;;int n,m,x,y,z;char map[maxQ+1][maxQ+1];algorithm task;void subtask();inline int read();int main()&#123; subtask(); return 0;&#125;void subtask()&#123; task.clear(); in(n); in(m); n++; m++; for(int i=1;i&lt;n;i++) scanf("%s",map[i]+1); for(int i=1;i&lt;n;i++) for(int j=1;j&lt;m;j++) if(map[i][j]==92) &#123; task.addtwo(i*m-m+j,i*m+j+1,0); task.addtwo(i*m-m+j+1,i*m+j,1); &#125; else &#123; task.addtwo(i*m-m+j,i*m+j+1,1); task.addtwo(i*m-m+j+1,i*m+j,0); &#125; task.dijkstra(1); if(task.dis[n*m]==0x3f3f3f3f) printf("NO SOLUTION\n"); else printf("%d\n",task.dis[n*m]);&#125;inline int read()&#123; char ch=getchar(); int num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') &#123;f=-1; ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123; num=num*10+ch-'0'; ch=getchar(); &#125; return num*f;&#125; ——然而并不是ACACAC。那几个TLE是什么意思！ 经过认真观察，突然发现： 时空限制 150ms / 128MB 显然，用priority queuepriority\ queuepriority queue是不够快的（然而吸氧过了），那当然是要用线段树优化了（堆：？？？），然后就去了解了一下线段树优化 DijkstraDijkstraDijkstra 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#define ls k&lt;&lt;1#define rs k&lt;&lt;1|1#define mid ((l+r)&gt;&gt;1)#define in(x) x=read();using namespace std;const int maxN=500001,maxM=1000001;const int inf=0x3f3f3f3f,maxQ=500;class algorithm&#123; public: int dis[maxN+1]; void addedge(int x,int y,int value) &#123; tot++; edge[tot].from=x; edge[tot].to=y; edge[tot].value=value; edge[tot].next=head[x]; head[x]=tot; &#125; void addtwo(int x,int y,int value) &#123; addedge(x,y,value); addedge(y,x,value); &#125; void clear() &#123; memset(dis,0x3f,sizeof(dis)); memset(vis,false,sizeof(vis)); memset(head,0,sizeof(head)); memset(sum,0x3f,sizeof(sum)); tot=0; &#125; void update(int k,int l,int r,int u,int w) &#123; if(l==r) &#123;sum[k]=w; return;&#125; if(u&lt;=mid) update(ls,l,mid,u,w); else update(rs,mid+1,r,u,w); pushup(k); &#125; int query(int k,int l,int r) &#123; if(l==r) return l; if(sum[ls]&lt;sum[rs]) return query(ls,l,mid); else return query(rs,mid+1,r); &#125; void dijkstra(int s,int n) &#123; dis[s]=0; update(1,1,n,s,0); while(sum[1]^inf) &#123; int x=query(1,1,n); update(1,1,n,x,inf); for(int i=head[x];i;i=edge[i].next) if(dis[edge[i].to]&gt;dis[x]+edge[i].value) &#123; dis[edge[i].to]=dis[x]+edge[i].value; update(1,1,n,edge[i].to,dis[edge[i].to]); &#125; &#125; &#125; private: struct Node &#123; int value,from,to,next; &#125;edge[maxM+1]; int head[maxN+1],tot,sum[4*maxN+1]; bool vis[maxN+1]; void pushup(int k) &#123;sum[k]=min(sum[ls],sum[rs]);&#125;&#125;;int n,m,x,y,z;char map[maxQ+1][maxQ+1];algorithm task;void subtask();inline int read();int main()&#123; subtask(); return 0;&#125;void subtask()&#123; task.clear(); in(n); in(m); n++; m++; for(int i=1;i&lt;n;i++) scanf("%s",map[i]+1); for(int i=1;i&lt;n;i++) for(int j=1;j&lt;m;j++) if(map[i][j]==92) &#123; task.addtwo(i*m-m+j,i*m+j+1,0); task.addtwo(i*m-m+j+1,i*m+j,1); &#125; else &#123; task.addtwo(i*m-m+j,i*m+j+1,1); task.addtwo(i*m-m+j+1,i*m+j,0); &#125; task.dijkstra(1,n*m); if(task.dis[n*m]==0x3f3f3f3f) printf("NO SOLUTION\n"); else printf("%d\n",task.dis[n*m]);&#125;inline int read()&#123; char ch=getchar(); int num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') &#123;f=-1; ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123; num=num*10+ch-'0'; ch=getchar(); &#125; return num*f;&#125; 令人欣慰的绿色： 然而并没有（逃） 普通线段树同学不够优秀（然而吸氧又过了），那当然是要用zkw线段树优化了（线段树：？？？），然后就又去借(chao)鉴(lai)了一下zkw线段树优化 DijkstraDijkstraDijkstra 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define ls x&lt;&lt;1#define rs x&lt;&lt;1|1#define in(x) x=read();using namespace std;const int maxN=500001,maxM=1000001;const int inf=0x7fffffff,maxQ=500;class algorithm&#123; public: int dis[maxN+1],ans[maxN+1]; inline void build(int size) &#123; for(leaf=1;leaf&lt;=size;leaf&lt;&lt;=1); leaf--; for(int i=1;i&lt;=size;++i) tree[leaf+i]=i; &#125; void update(int x,int y) &#123; dis[x]=y; x+=leaf; x&gt;&gt;=1; while(x) &#123; tree[x]=(dis[tree[ls]]&lt;dis[tree[rs]])?tree[ls]:tree[rs]; x&gt;&gt;=1; &#125; &#125; inline void addedge(int x,int y,int value) &#123; edge[++tot].from=x; edge[tot].to=y; edge[tot].value=value; edge[tot].next=head[x]; head[x]=tot; &#125; inline void addtwo(int x,int y,int value) &#123; addedge(x,y,value); addedge(y,x,value); &#125; inline void clear() &#123; memset(dis,0x3f,sizeof(dis)); memset(tree,0,sizeof(tree)); memset(ans,0x3f,sizeof(ans)); tot=0; &#125; void dijkstra(int s,int size) &#123; build(size); dis[s]=0; int x=s,dist; for(int i=1;i&lt;=size;++i) &#123; dist=ans[x]=dis[x]; update(x,inf); for(int i=head[x];i;i=edge[i].next) if(dis[edge[i].to]&lt;inf &amp;&amp; dis[edge[i].to]&gt;dist+edge[i].value) update(edge[i].to,dist+edge[i].value); x=tree[1]; &#125; &#125; private: struct Node &#123; int value,from,to,next; &#125;edge[maxM+1]; int head[maxN+1],tot,tree[maxN&lt;&lt;2],leaf;&#125;;int n,m,x,y,z;char map[maxQ+1][maxQ+1];algorithm task;void subtask();inline int read();int main()&#123; subtask(); return 0;&#125;void subtask()&#123; task.clear(); in(n); in(m); n++; m++; for(int i=1;i&lt;n;i++) scanf("%s",map[i]+1); for(int i=1;i&lt;n;i++) for(int j=1;j&lt;m;j++) if(map[i][j]==92) &#123; task.addtwo(i*m-m+j,i*m+j+1,0); task.addtwo(i*m-m+j+1,i*m+j,1); &#125; else &#123; task.addtwo(i*m-m+j,i*m+j+1,1); task.addtwo(i*m-m+j+1,i*m+j,0); &#125; task.dijkstra(1,n*m); if(task.ans[n*m]!=0x3f3f3f3f) printf("%d",task.ans[n*m]); else printf("NO SOLUTION");&#125;inline int read()&#123; char ch=getchar(); int num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') &#123;f=-1; ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123; num=num*10+ch-'0'; ch=getchar(); &#125; return num*f;&#125; 真 · 令人欣慰的绿色~~（无吸氧）~~： （后来看题解发现貌似手写堆也能过QWQ （太懒而不想写），卡常技术还有待提高啊）]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>zkw线段树</tag>
        <tag>堆</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1937 仓配置]]></title>
    <url>%2Fpassages%2F2019-04-07-P1937%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1937 仓配置 题目描述： 如图，牛栏里只能容纳一定空间，进行线段覆盖，且覆盖数不能超过空间，求最大线段数 12345678畜栏号: 1 2 3 4 5 +---+---+---+---+---+容纳空间: | 1 | 3 | 2 | 1 | 3 | +---+---+---+---+---+Cow 1 XXXXXXXXXXXXX (1, 3)Cow 2 XXXXXXXXXXXXXXXX (2, 5)Cow 3 XXXXXXXX (2, 3)Cow 4 XXXXXXXX (4, 5) 算法分析：考虑贪心：先让靠右的、占线段长度最小的入驻，这样就能避免覆盖中的重合问题。这样排序，然后用线段树维护当前区间剩余数量的最小值，若能入住 (query&gt;0query&gt;0query&gt;0) 就将空间减少 (updateupdateupdate) 即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;algorithm&gt;#define rd int#define in(x) x=read()#define ls k&lt;&lt;1#define rs k&lt;&lt;1 | 1#define mid ((l+r)&gt;&gt;1)#define maxN 100010#define G ch=getchar()#define lson ls,l,mid#define rson rs,mid+1,r#define f(x,y) for(register int i=x;i&lt;=y;++i)#define q(x,y) tree.query(1,1,n,x,y,0)#define u(x,y) tree.update(1,1,n,x,y,-1),tot++#define S a[i].s#define T a[i].tusing namespace std;inline rd read();struct Query&#123; int s,t;&#125;a[maxN+1];class segment_tree&#123; public: void build(int k,int l,int r) &#123; if(l==r) &#123;in(sum[k]); return;&#125; build(lson); build(rson); pushup(k); &#125; void update(int k,int l,int r,int ql,int qr,int w) &#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;sum[k]+=w; v[k]+=w; return;&#125; if(v[k]) pushdown(k,l,r); if(ql&lt;=mid) update(lson,ql,qr,w); if(qr&gt;mid) update(rson,ql,qr,w); pushup(k); &#125; int query(int k,int l,int r,int ql,int qr,int w) &#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sum[k]; int ans=INT_MAX; if(v[k]) pushdown(k,l,r); if(ql&lt;=mid) ans=min(ans,query(lson,ql,qr,w)); if(qr&gt;mid) ans=min(ans,query(rson,ql,qr,w)); return ans; &#125; private: void pushup(int k) &#123;sum[k]=min(sum[ls],sum[rs]);&#125; void pushdown(int k,int l,int r) &#123; v[ls]+=v[k]; v[rs]+=v[k]; sum[ls]+=v[k]; sum[rs]+=v[k]; v[k]=0; &#125; int v[4*maxN+1],sum[4*maxN+1];&#125;;segment_tree tree;void subtask();int n,m,tot=0;bool comp(Query x,Query y) &#123;return (x.t!=y.t)?(x.t&lt;y.t):(x.s&gt;y.s);&#125;int main()&#123; subtask(); return 0;&#125;void subtask()&#123; in(n); in(m); tree.build(1,1,n); f(1,m) &#123;in(a[i].s); in(a[i].t);&#125; sort(a+1,a+m+1,comp); f(1,m) if(q(S,T)&gt;0) u(S,T); printf("%d",tot);&#125;inline rd read()&#123; rd num=0,f=1; char ch=getchar(); while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') G; if(ch=='-') &#123;f=-1; G;&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123;num=num*10+ch-'0'; G;&#125; return num*f;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化线段树——主席树]]></title>
    <url>%2Fpassages%2F2019-04-07-presi-tree%2F</url>
    <content type="text"><![CDATA[前言： 最近心(po)血(yu)来(ya)潮(li)学习了一下主席树。（再不学就落伍了） 主席树，即可持久化线段树，支持维护和查询区间的第kkk大（小）、区间不同种类个数等，基于线段树的思想 结构分析 主席树会维护[1,n][1,n][1,n]中点的个数（可以理解为，一颗弹珠从树根放下，滑到叶节点时，走过的路径都+1+1+1） 现在假设有一组数 {a1,a2,...,a7}\{a_1,a_2,...,a_7\}{a​1​​,a​2​​,...,a​7​​}，离散化后编号为 {1,2,...,7}\{1,2,...,7\}{1,2,...,7}，现在以{1,7,6,2,3,5,4}\{1,7,6,2,3,5,4\}{1,7,6,2,3,5,4}的顺序进入主席树 下面来演示一下这个过程~~（PowerPoint冠名）~~ 下面来张动图~~（PowerPoint冠名）~~ 耐心等一会，总会等到GIF开头的（该动图时长32秒） 那么通过这种结构该如何寻找区间第kkk大（小）值呢？ 算法实现 还是原来的数组 {1,7,6,2,3,5,4}\{1,7,6,2,3,5,4\}{1,7,6,2,3,5,4}，现在来举个栗子：求[2,5]({7,6,2,3})[2,5](\{7,6,2,3\})[2,5]({7,6,2,3})这一段的第222小值（333） 首先要了解这样一个概念：求区间第kkk小值，相当于在区间内找一个值，使有kkk个数小于等于这个值~~（废话）~~ 不(hen)难发现，在主席树里，左子树的值一定小于右子树的值。那么，只要判断左子树里的数的个数是否≥2\ge2≥2，如果是，那么区间第222小值一定在左子树里，反之在右子树里 那么能否建NNN棵线段树呢？ MLE:小朋友，我来了！ 通过认真的观察，发现—— 这两张图中，真正修改了值的节点并不多。这时，两棵线段树完全可以使用共用的节点，这样就可以大大的降低空间复杂度。那么，该如何处理[l,r][l,r][l,r]中比当前值小的数的个数呢？ 这里就要用到二分和前缀和的思想了。举个栗子，如果[1,l−1][1,l-1][1,l−1]中有sum1sum_1sum​1​​个数比当前值小，[1,r][1,r][1,r]中有sum2sum_2sum​2​​个数比当前值小，那么[l,r][l,r][l,r]中就有 sum2−sum1sum_2-sum_1sum​2​​−sum​1​​个值比当前值小 回到刚才的问题： 数组 {1,7,6,2,3,5,4}\{1,7,6,2,3,5,4\}{1,7,6,2,3,5,4}，求[2,5]({7,6,2,3})[2,5](\{7,6,2,3\})[2,5]({7,6,2,3})这一段的第222小值（333） 我们挑出第(2−1)(2-1)(2−1)次插入时的树和第555次插入时的树，经过观察—— 你发现了什么？ 举个栗子，我们看上一棵树中的代表[5,7][5,7][5,7]的节点和下一棵树的对应节点，可以发现：它们的差就是{7,6,2,3}\{7,6,2,3\}{7,6,2,3}中在[5,7][5,7][5,7]上的数的个数。那么，上一棵树中的代表[1,4][1,4][1,4]的节点和下一棵树的对应节点之差为222，这说明第222小值必定在[1,4][1,4][1,4]区间内，由此即可求出第222小值——333 代码实现 L,RL,RL,R 表示左右子树，sumsumsum 就是图中所维护的维护[1,n][1,n][1,n]中点的个数，rankrankrank 为离散化数组，rootrootroot 表示这么多线段树的根。答案递归求解即可。( fm(x)fm(x)fm(x) 表示初始化 xxx ) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define f(x,y) for(register int i=x;i&lt;=y;i++)#define G ch=getchar()#define rd int#define in(x) x=read();#define node int#define mid ((l+r)&gt;&gt;1)#define fm(x) memset(x,0,sizeof(x))#define maxN 200000using namespace std;inline rd read();class president_tree&#123; public: node query(int x,int y,int w) &#123;return rank[_query(root[x-1],root[y],1,_size,w)];&#125; void build(int a[],int n) &#123; tot=0; fm(rank); fm(root); fm(sum); fm(L); fm(R); for(register int i=1;i&lt;=n;i++) rank[i]=a[i]; sort(rank+1,rank+n+1); _size=unique(rank+1,rank+n+1)-rank-1; root[0]=_build(1,_size); for(register int i=1;i&lt;=n;i++) root[i]=update(root[i-1],1,_size,lower_bound(rank+1,rank+_size+1,a[i])-rank); &#125; private: int tot,_size; node rank[maxN+1],root[maxN+1],sum[(maxN&lt;&lt;5)+1],L[(maxN&lt;&lt;5)+1],R[(maxN&lt;&lt;5)+1];; node _build(int l,int r) &#123; int k=++tot; sum[k]=0; if(l&lt;r) &#123; L[k]=_build(l,mid); R[k]=_build(mid+1,r); &#125; return k; &#125; node update(int pre,int l,int r,int w) &#123; int k=++tot; L[k]=L[pre]; R[k]=R[pre]; sum[k]=sum[pre]+1; if(l&lt;r) if(w&lt;=mid) L[k]=update(L[pre],l,mid,w); else R[k]=update(R[pre],mid+1,r,w); return k; &#125; node _query(int u,int v,int l,int r,int k) &#123; if(l&gt;=r) return l; int w=sum[L[v]]-sum[L[u]]; if(w&gt;=k) return _query(L[u],L[v],l,mid,k); else return _query(R[u],R[v],mid+1,r,k-w); &#125;&#125;;int n,m,a[maxN+1],b[maxN+1],x,y,w;president_tree tree;int main()&#123; in(n); in(m); f(1,n) in(a[i]); tree.build(a,n); f(1,m) &#123; in(x); in(y); in(w); printf("%d\n",tree.query(x,y,w)); &#125; return 0;&#125;inline rd read()&#123; char ch=getchar(); rd num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') G; if(ch=='-') &#123;f=-1; G;&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123;num=num*10+ch-'0'; G;&#125; return num*f;&#125; 写在最后 对主席树的认识与理解，到这篇博客的诞生，是起源于这两位巨佬的博客的—— 最详细的讲解，让你一次学会主席树 【Notes】【主席树】hdu2665 Kth number 在此表示衷心的感谢！ （我才不会告诉你这篇博客写到一半未保存，网页就莫名其妙关闭了呢 QWQ）]]></content>
      <categories>
        <category>Models</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P3948 数据结构]]></title>
    <url>%2Fpassages%2F2019-04-07-P3948%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P3948 数据结构 题目描述： 维护一个数组，使其能区间修改，并动态查询某区间内满足min≤(ai×i % mod)≤maxmin\leq(a_i\times i\ \%\ mod)\leq maxmin≤(a​i​​×i % mod)≤max 的数的个数 算法分析：该题操作共两个阶段—— 1、在线：要求动态修改，但数据量很小（≤1000\leq 1000≤1000），可以暴力查询，区间修改，单点查询 2、离线：不要求动态修改，但数据量很大（≤10000000\leq 10000000≤10000000），可以预处理，然后区间查询 如上，跑两个树状数组即可。 事实证明，树状数组只能得72分，为了用数据结构（正解不用树状结构），吸个氧就过了（最大点490ms） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define node int#define maxN 80000#define in(x) x=read()using namespace std;class binary_tree&#123; public: inline node query(int x,int y) &#123;return (y+1)*sum(tree1,y)-sum(tree2,y)-x*sum(tree1,x-1)+sum(tree2,x-1);&#125; inline void build(node a[]) &#123;for(register int i=1;i&lt;=tot;i++) modify(i,a[i]-a[i-1]);&#125; inline void update(node x,node y,node k) &#123;modify(x,k); modify(y+1,-k);&#125; inline void clear(int n) &#123;tot=n; memset(tree1,0,sizeof(tree1)); memset(tree2,0,sizeof(tree2));&#125; private: node tree1[maxN+1],tree2[maxN+1],tot; inline node lowbit(node x) &#123;return x&amp;(-x);&#125; inline node sum(node a[],node x) &#123;node ans=0; while(x&gt;0) &#123;ans+=a[x]; x-=lowbit(x);&#125; return ans;&#125; inline void modify(node x,node k) &#123;for(register node i=x;i&lt;=tot;i+=lowbit(i)) &#123;tree1[i]+=k; tree2[i]+=k*x;&#125;&#125;&#125;;typedef int ll;ll l,r,k,read(); char s[2];int n,m,D,minT,maxT,check(int);binary_tree treeA,treeB;inline void task1(),task2();int main()&#123; task1(); task2(); return 0;&#125;inline int check(int x)&#123; ll now=treeA.query(x,x)%D; if(minT&lt;=((x*now)%D) &amp;&amp; ((x*now)%D)&lt;=maxT) return 1; return 0;&#125;inline void task1()&#123; in(n); in(m); in(D); in(minT); in(maxT); treeA.clear(n); for(register int i=1;i&lt;=m;i++) &#123; scanf("%s",s); in(l); in(r); if(s[0]=='A') treeA.update(l,r,read()); else &#123; ll ans=0; for(register int j=l;j&lt;=r;j++) ans+=check(j); printf("%d\n",ans); &#125; &#125;&#125;inline void task2()&#123; in(m); treeB.clear(n); for(register int i=1;i&lt;=n;i++) if(check(i)) treeB.update(i,i,1); for(register int i=1;i&lt;=m;i++) &#123; in(l); in(r); printf("%d\n",treeB.query(l,r)); &#125;&#125;inline ll read()&#123; ll num=0,f=1; char ch=getchar(); while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') &#123;f=-1; ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+ch-'0'; ch=getchar(); &#125; return num*f;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPOJ Can you answer these queries 系列]]></title>
    <url>%2Fpassages%2F2019-04-07-SPOJ-GSS%2F</url>
    <content type="text"><![CDATA[传送门 I：Can you answer these queries I II：Can you answer these queries II III：Can you answer these queries III IV：Can you answer these queries IV V：Can you answer these queries V VI：Can you answer these queries VI VII：Can you answer these queries VII VIII：Can you answer these queries VIII 题目描述： I：区间最大子段和 II：区间最大子段和（相同的数只算一次） III：支持单点修改的区间最大子段和 IV：区间开平方运算，并区间求和 V：查询左端点在[x1,y1][x1,y1][x1,y1]之间，且右端点在[x2,y2][x2,y2][x2,y2]之间的最大子段和 VI：支持动态插入、删除、修改的区间最大子段和 VII：在一棵树上，支持修改整条链的权值的链上最大子段和 VIII：给定一个数列，支持如下操作： 插入一个数字在第pospospos个位置之前 删除第pospospos个元素 将第pospospos个元素变为val 询问(∑i=lrA[i]×(i−l+1)k) mod 232(\sum_{i=l}^rA[i]\times(i-l+1)^k)\ mod\ 2^{32}(∑​i=l​r​​A[i]×(i−l+1)​k​​) mod 2​32​​ 题解 Can you answer these queries I Can you answer these queries I Can you answer these queries II Can you answer these queries II Can you answer these queries III Can you answer these queries III Can you answer these queries IV 传送门：Can you answer these queries IV 重题：洛谷 P4145 上帝造题的七分钟2 / 花神游历各国 题目描述：区间开平方运算，并区间求和 算法分析：x\sqrt{x}√​x​​​ 向下取整，那么∀x∈R\forall x \in R∀x∈R，在经过有限次开平方运算后，其结果一定为111。故只需将大于111的区间的数开平方即可，就能大大降低时间复杂度，然后在更新时只要递归修改即可（101810^{18}10​18​​至多需要6次修改），查询时区间查询。在这里用了两个数组：sumsumsum 和 maximaximaxi，sumsumsum存储和，maximaximaxi储存区间最大值。若区间最大值 &gt;1&gt;1&gt;1，则需修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define G ch=getchar()#define in(x) x=read()using namespace std;typedef long long ll;inline ll read()&#123; char ch=getchar(); ll num=0,f=1; while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') G; if(ch=='-') &#123;f=-1; G;&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123;num=num*10+ch-'0'; G;&#125; return num*f;&#125;class segment_tree&#123; #define ls k&lt;&lt;1 #define rs k&lt;&lt;1 | 1 #define mid ((l+r)&gt;&gt;1) #define S(x) x=(int)sqrt(x) #define SIZE 100000 public: void clear() &#123;memset(sum,0,sizeof(sum)); memset(maxi,0,sizeof(maxi));&#125; void update(int k,int l,int r,int ql,int qr) &#123; if(l==r) &#123;S(sum[k]); S(maxi[k]); return;&#125; if(ql&lt;=mid &amp;&amp; maxi[ls]&gt;1) update(ls,l,mid,ql,qr); if(qr&gt;mid &amp;&amp; maxi[rs]&gt;1) update(rs,mid+1,r,ql,qr); pushup(k); &#125; ll query(int k,int l,int r,int ql,int qr) &#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sum[k]; ll ans=0; if(ql&lt;=mid) ans+=query(ls,l,mid,ql,qr); if(qr&gt;mid) ans+=query(rs,mid+1,r,ql,qr); return ans; &#125; void build(int k,int l,int r) &#123; if(l==r) &#123;in(sum[k]); maxi[k]=sum[k]; return;&#125; build(ls,l,mid); build(rs,mid+1,r); pushup(k); &#125; private: ll sum[4*SIZE+1],maxi[4*SIZE+1]; void pushup(int k) &#123;sum[k]=sum[ls]+sum[rs]; maxi[k]=max(maxi[ls],maxi[rs]);&#125; #undef ls #undef rs #undef mid #undef S&#125;;segment_tree tree;int n,m,l,r,op,t;void subtask(int);int main()&#123; while(~scanf("%d",&amp;n)) &#123;t++; subtask(t);&#125; return 0;&#125;void subtask(int _case)&#123; printf("Case #%d:\n",_case); tree.clear(); tree.build(1,1,n); in(m); for(register int i=1;i&lt;=m;i++) &#123; in(op); in(l); in(r); if(l&gt;r) swap(l,r); if(op==0) tree.update(1,1,n,l,r); else printf("%lld\n",tree.query(1,1,n,l,r)); &#125; printf("\n");&#125; Can you answer these queries V Can you answer these queries V Can you answer these queries VI Can you answer these queries VI Can you answer these queries VII Can you answer these queries VII Can you answer these queries VIII Can you answer these queries VIII]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P4392 Sound 静音问题]]></title>
    <url>%2Fpassages%2F2019-04-07-P4392%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P4392 Sound 静音问题 题目描述： 求数组区间最大（小） 算法分析：模板即可（然而调了半个小时——取最小值的时候忘记取最大值了QWQ） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define maxN 1000010#define ls k&lt;&lt;1#define rs k&lt;&lt;1 | 1#define mid ((l+r)&gt;&gt;1)#define node int#define in(x) x=read()using namespace std;inline int read()&#123; int num=0,f=1; char ch=getchar(); while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') &#123;f=-1; ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+ch-'0'; ch=getchar(); &#125; return num*f;&#125;class segment_tree&#123; public: node qmax(int l,int r) &#123;return query(sum1,1,1,1,tot,l,r);&#125; node qmin(int l,int r) &#123;return query(sum2,2,1,1,tot,l,r);&#125; void build(int k,int l,int r) &#123; if(l==r) &#123;in(sum1[k]); sum2[k]=sum1[k]; return;&#125; build(ls,l,mid); build(rs,mid+1,r); sum1[k]=max(sum1[ls],sum1[rs]); sum2[k]=min(sum2[ls],sum2[rs]); &#125; void clear(int n) &#123;memset(sum1,0,sizeof(sum1)); memset(sum2,0x3f,sizeof(sum2)); tot=n;&#125; private: node sum1[4*maxN+1],sum2[4*maxN+1]; int tot; node query(node sum[],int op,int k,int l,int r,int ql,int qr) &#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sum[k]; node maxT=0,minT=0x3f3f3f3f; if(ql&lt;=mid) maxT=minT=query(sum,op,ls,l,mid,ql,qr); if(op==1 &amp;&amp; qr&gt;mid) maxT=max(maxT,query(sum,op,rs,mid+1,r,ql,qr)); if(op==2 &amp;&amp; qr&gt;mid) minT=min(minT,query(sum,op,rs,mid+1,r,ql,qr)); return (op==1)?maxT:minT; &#125;&#125;;segment_tree tree;int n,m,c,f=1;int main()&#123; in(n); in(m); in(c); tree.clear(n); tree.build(1,1,n); for(int i=1;i&lt;=n-m+1;i++) if(tree.qmax(i,i+m-1)-tree.qmin(i,i+m-1)&lt;=c) &#123;printf("%d\n",i); f=0;&#125; if(f) printf("NONE"); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1487 失落的成绩单]]></title>
    <url>%2Fpassages%2F2019-04-07-P1487%2F</url>
    <content type="text"><![CDATA[传送门：洛谷 P1487 失落的成绩单 题目描述： 数列 aaa 满足 Ai=Ai−1−Ai+12+dA_i=\frac{A_{i-1}-A_{i+1}}{2}+d A​i​​=​2​​A​i−1​​−A​i+1​​​​+d 给出：首项 A1A_1A​1​​、末项 AnA_nA​n​​、ddd、mmm，求AmA_mA​m​​ 算法分析： 矩阵快速幂？还没学，所以我们就用数(mo)学(fa)来解决这道题。 预备知识：特征方程 我们以这个式子为例—— fi=fi−1+6fi−2f_i=f_{i-1}+6f_{i-2}f​i​​=f​i−1​​+6f​i−2​​ 首先我们来看两个数集 A={x∣x=(−2)k,k∈N∗} , B={x∣x=3k,k∈N∗}A=\{x\mid x=(-2)^k,k\in\mathbb{N^*}\}\ ,\ B=\{x\mid x=3^k,k\in\mathbb{N^*}\}A={x∣x=(−2)​k​​,k∈N​∗​​} , B={x∣x=3​k​​,k∈N​∗​​} 那么，我们可以列出 AAA 的前几项：−2,4,−8,16,...-2,4,-8,16,...−2,4,−8,16,...，BBB 的前几项：3,9,27,81,...3,9,27,81,...3,9,27,81,... 将 AAA 代入递推式，神奇的发现—— f1=−2f_1=-2 f​1​​=−2 f2=4f_2=4 f​2​​=4 f3=4+6×(−2)=−8f_3=4+6\times(-2)=-8 f​3​​=4+6×(−2)=−8 f4=−8+6×4=16f_4=-8+6\times4=16 f​4​​=−8+6×4=16 ............ ...... AAA 中的数都满足上述的递推式，同样的，BBB 也满足。 很明显，fi=(−2)kf_i=(-2)^kf​i​​=(−2)​k​​ 和 fi=3kf_i=3^kf​i​​=3​k​​ 都是上述递推式的通项公式 下面我们来看两个引理—— 1、若 fi=aif_i=a^if​i​​=a​i​​ 是某一递推式的通项公式，那么，fi=λaif_i=\lambda a^if​i​​=λa​i​​ 同样满足递推式（两边同乘上系数即可） 2、若 fi=aif_i=a^if​i​​=a​i​​ 和 fi=bif_i=b^if​i​​=b​i​​ 都满足递推式，那么，fi=α×ai+β×bif_i=\alpha\times a^i+\beta\times b^if​i​​=α×a​i​​+β×b​i​​ 同样满足（两式乘上系数相加即可） 接下来，我们来看一个经典的例子——斐波拉契数列 fi=fi−1+fi−2f_i=f_{i-1}+f_{i-2}f​i​​=f​i−1​​+f​i−2​​ 现在我们不能像刚才那个式子“观察”出一个通解了，那么就需要我们自己进行构造~~（自己动手，丰衣足食）~~ 现在我们设存在一组等比数列满足这个递推式~~（不是等比怎么约分啊）~~，其公比为 qqq ，那么我们看一下这个式子—— fi=fi−1+fi−2f_i=f_{i-1}+f_{i-2} f​i​​=f​i−1​​+f​i−2​​ q2×fi−2=q×fi−2+fi−2q^2\times f_{i-2}=q\times f_{i-2}+f_{i-2} q​2​​×f​i−2​​=q×f​i−2​​+f​i−2​​ q2=q+1q^2=q+1 q​2​​=q+1 q2−q−1=0q^2-q-1=0 q​2​​−q−1=0 这就是斐波拉契数列的特征方程 把它解出来，可以得到—— q1=5+12,q2=−5+12q_1=\frac{\sqrt5+1}{2},q_2=\frac{-\sqrt5+1}{2}q​1​​=​2​​√​5​​​+1​​,q​2​​=​2​​−√​5​​​+1​​ 那么，我们就知道了——公比为±5+12\frac{\pm\sqrt5+1}{2}​2​​±√​5​​​+1​​的等比数列满足斐波拉契数列 那么，我们又知道了数列的前两项：f1=f2=1f_1=f_2=1f​1​​=f​2​​=1 我们设 fi=α×(5+12)i+β×(−5+12)if_i=\alpha\times(\frac{\sqrt5+1}{2})^i+\beta\times(\frac{-\sqrt5+1}{2})^if​i​​=α×(​2​​√​5​​​+1​​)​i​​+β×(​2​​−√​5​​​+1​​)​i​​，代入f1,f2f_1,f_2f​1​​,f​2​​ 则—— {α(5+12)+β(−5+12)=f1=1α(5+12)2+β(−5+12)2=f2=1\begin{cases} \alpha(\frac{\sqrt5+1}{2})+\beta(\frac{-\sqrt5+1}{2})=f_1=1\\ \\ \alpha(\frac{\sqrt5+1}{2})^2+\beta(\frac{-\sqrt5+1}{2})^2=f_2=1\\ \end{cases} ​⎩​⎪​⎪​⎪​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎪​⎪​⎪​⎧​​​α(​2​​√​5​​​+1​​)+β(​2​​−√​5​​​+1​​)=f​1​​=1​​α(​2​​√​5​​​+1​​)​2​​+β(​2​​−√​5​​​+1​​)​2​​=f​2​​=1​​​ 得 α=55,β=−55\alpha=\frac{\sqrt5}{5},\beta=-\frac{\sqrt5}{5}α=​5​​√​5​​​​​,β=−​5​​√​5​​​​​，这样，我们就求出了通项公式 回到之前的递推数列——fi=fi−1+6fi−2f_i=f_{i-1}+6f_{i-2}f​i​​=f​i−1​​+6f​i−2​​，怎么得出其通解的？ 其实很简单。我们设等比数列公比为 qqq，就可以得到特征方程—— q2−q−6=0⇒q1=−2,q2=3q^2-q-6=0 \Rightarrow q_1=-2,q_2=3q​2​​−q−6=0⇒q​1​​=−2,q​2​​=3 进入正题，首先来膜改一下式子： Ai=Ai−1−Ai+12+dA_i=\frac{A_{i-1}-A_{i+1}}{2}+d A​i​​=​2​​A​i−1​​−A​i+1​​​​+d 2Ai=Ai−1−Ai+1+2d2A_i=A_{i-1}-A_{i+1}+2d 2A​i​​=A​i−1​​−A​i+1​​+2d Ai+1=−2Ai+Ai−1+2dA_{i+1}=-2A_{i}+A_{i-1}+2d A​i+1​​=−2A​i​​+A​i−1​​+2d 这是 AAA 的递推式，我们将 iii 减 111： Ai=−2Ai−1+Ai−2+2dA_{i}=-2A_{i-1}+A_{i-2}+2d A​i​​=−2A​i−1​​+A​i−2​​+2d 现在我们得出了答案 —— Ai=−2Ai−1+Ai−2+2dA_{i}=-2A_{i-1}+A_{i-2}+2dA​i​​=−2A​i−1​​+A​i−2​​+2d 那么我们先将 2d2d2d 放在一边，设数列 aaa 满足 ai=−2ai−1+ai−2a_{i}=-2a_{i-1}+a_{i-2}a​i​​=−2a​i−1​​+a​i−2​​ 设此数列公比为 qqq，现在代入—— q2ai−2=−2qai−2+ai−2q^2a_{i-2}=-2qa_{i-2}+a_{i-2} q​2​​a​i−2​​=−2qa​i−2​​+a​i−2​​ q2+2q−1=0q^2+2q-1=0 q​2​​+2q−1=0 这就是上述递推式的特征方程 现在解一下这个方程，可以得到—— q1=−2−1,q2=2−1q_1=-\sqrt{2}-1,q_2=\sqrt{2}-1q​1​​=−√​2​​​−1,q​2​​=√​2​​​−1 那么我们就可以得到这个数列的通项公式—— ai=α(−2−1)i+β(2−1)ia_i=\alpha(-\sqrt{2}-1)^i+\beta(\sqrt{2}-1)^i a​i​​=α(−√​2​​​−1)​i​​+β(√​2​​​−1)​i​​ 其中 i≤ni\leq ni≤n，并且 {α(−2−1)+β(2−1)=a1α(−2−1)n+β(2−1)n=an\begin{cases} \alpha(-\sqrt{2}-1)+\beta(\sqrt{2}-1)=a_1\\ \alpha(-\sqrt{2}-1)^n+\beta(\sqrt{2}-1)^n=a_n\\ \end{cases} ​⎩​⎪​⎨​⎪​⎧​​​α(−√​2​​​−1)+β(√​2​​​−1)=a​1​​​α(−√​2​​​−1)​n​​+β(√​2​​​−1)​n​​=a​n​​​​​ 将上面的方程解出来，我们可以得到—— {α=a1(2−1)n−1−an(−2−1)(2−1)n−1−(−2−1)nβ=a1(−2−1)n−1−an(2−1)(−2−1)n−1−(2−1)n\begin{cases} \alpha=\frac{a_1(\sqrt{2}-1)^{n-1}-a_n}{(-\sqrt{2}-1)(\sqrt{2}-1)^{n-1}-(-\sqrt{2}-1)^n}\\ \\ \beta=\frac{a_1(-\sqrt{2}-1)^{n-1}-a_n}{(\sqrt{2}-1)(-\sqrt{2}-1)^{n-1}-(\sqrt{2}-1)^n}\\ \end{cases} ​⎩​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎧​​​α=​(−√​2​​​−1)(√​2​​​−1)​n−1​​−(−√​2​​​−1)​n​​​​a​1​​(√​2​​​−1)​n−1​​−a​n​​​​​​β=​(√​2​​​−1)(−√​2​​​−1)​n−1​​−(√​2​​​−1)​n​​​​a​1​​(−√​2​​​−1)​n−1​​−a​n​​​​​​​ 代入通项公式并整理—— am=an[(2−1)m−1−(−1)m−1(2+1)m−1]+(−1)m−1a1[(2−1)n−m−(−2−1)n−m](2−1)n−1−(−1)n−1(2+1)n−1a_m=\frac{a_n[(\sqrt{2}-1)^{m-1}-(-1)^{m-1}(\sqrt{2}+1)^{m-1}]+(-1)^{m-1}a_1[(\sqrt{2}-1)^{n-m}-(-\sqrt{2}-1)^{n-m}]}{(\sqrt{2}-1)^{n-1}-(-1)^{n-1}(\sqrt{2}+1)^{n-1}} a​m​​=​(√​2​​​−1)​n−1​​−(−1)​n−1​​(√​2​​​+1)​n−1​​​​a​n​​[(√​2​​​−1)​m−1​​−(−1)​m−1​​(√​2​​​+1)​m−1​​]+(−1)​m−1​​a​1​​[(√​2​​​−1)​n−m​​−(−√​2​​​−1)​n−m​​]​​ 设f(x)=(2−1)x−(−1)x(2+1)xf(x)=(\sqrt2-1)^x-(-1)^x(\sqrt2+1)^xf(x)=(√​2​​​−1)​x​​−(−1)​x​​(√​2​​​+1)​x​​，可得 am=an×f(m−1)+(−1)m−1a1×f(n−m)f(n−1)a_m=\frac{a_n\times f(m-1)+(-1)^{m-1}a_1\times f(n-m)}{f(n-1)} a​m​​=​f(n−1)​​a​n​​×f(m−1)+(−1)​m−1​​a​1​​×f(n−m)​​ 好了，现在是最后一个问题——还有ddd呢！ 其实很容(kun)易(nan)，观察递推式—— Ai=−2Ai−1+Ai−2+2dA_i=-2A_{i-1}+A_{i-2}+2dA​i​​=−2A​i−1​​+A​i−2​​+2d 我们设 Ai=ai+p×dA_i=a_i+p\times dA​i​​=a​i​​+p×d，代入—— Ai=−2Ai−1+Ai−2+2dA_i=-2A_{i-1}+A_{i-2}+2d A​i​​=−2A​i−1​​+A​i−2​​+2d ai+pd=−2ai−1−2pd+ai−2+pd+2da_i+pd=-2a_{i-1}-2pd+a_{i-2}+pd+2d a​i​​+pd=−2a​i−1​​−2pd+a​i−2​​+pd+2d 我们又有 ai=−2ai−1+ai−2a_{i}=-2a_{i-1}+a_{i-2}a​i​​=−2a​i−1​​+a​i−2​​，那么两边约去，可得—— pd=−2pd+pd+2d⇒p=1pd=-2pd+pd+2d \Rightarrow p=1 pd=−2pd+pd+2d⇒p=1 故 Ai=ai+dA_i=a_i+dA​i​​=a​i​​+d 那么，根据题意，我们来膜改一下式子—— Am=(An−d)×f(m−1)+(−1)m−1(A1−d)×f(n−m)f(n−1)+dA_m=\frac{(A_n-d)\times f(m-1)+(-1)^{m-1}(A_1-d)\times f(n-m)}{f(n-1)}+d A​m​​=​f(n−1)​​(A​n​​−d)×f(m−1)+(−1)​m−1​​(A​1​​−d)×f(n−m)​​+d 这样，我们就得到了数列的通项公式，代码就很好写了~~（没用龟(kuai)速幂，数据太弱QwQ）~~ 123456789101112131415#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;const double p=sqrt(2)-1;int n,m; double d,a1,an;double c(int op) &#123;return (op&amp;1)?-1:1;&#125;double f(int x) &#123;return pow(p,x)-c(x)*pow(p+2,x);&#125;int main()&#123; scanf("%d%d%lf%lf%lf",&amp;n,&amp;m,&amp;d,&amp;a1,&amp;an); if(m==0) printf("0.000"); else printf("%.3lf",((an-d)*f(m-1)+c(m-1)*(a1-d)*f(n-m))/f(n-1)+d); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
</search>
